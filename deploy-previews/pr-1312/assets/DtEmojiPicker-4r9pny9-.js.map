{"version":3,"file":"DtEmojiPicker-4r9pny9-.js","sources":["../../components/emoji_picker/modules/emoji_search.vue","../../components/emoji_picker/emoji_picker_constants.js","../../components/emoji_picker/modules/emoji_tabset.vue","../../components/emoji_picker/composables/useKeyboardNavigation.js","../../components/emoji_picker/modules/emoji_selector.vue","../../components/emoji_picker/modules/emoji_skin_selector.vue","../../components/emoji_picker/DtEmojiPicker.vue"],"sourcesContent":["<template>\n  <div class=\"d-emoji-picker__search d-emoji-picker__alignment\">\n    <dt-input\n      id=\"searchInput\"\n      ref=\"searchInput\"\n      :placeholder=\"searchPlaceholderLabel\"\n      :model-value=\"modelValue\"\n      @update:model-value=\"$emit('update:modelValue', $event)\"\n      @keydown.up=\"$emit('focus-tabset')\"\n      @keydown.down.prevent=\"$emit('focus-emoji-selector')\"\n      @keydown.enter=\"$emit('select-first-emoji')\"\n    >\n      <template #leftIcon>\n        <dt-icon name=\"search\" />\n      </template>\n      <template\n        v-if=\"modelValue.length > 0\"\n        #rightIcon\n      >\n        <button\n          class=\"d-emoji-picker__search-button\"\n          @click=\"clearSearch\"\n          @keydown.enter=\"clearSearch\"\n        >\n          <dt-icon\n            name=\"close\"\n          />\n        </button>\n      </template>\n    </dt-input>\n  </div>\n</template>\n\n<script setup>\nimport DtInput from '@/components/input/input.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { onMounted, ref } from 'vue';\n\ndefineProps({\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n});\n\nconst emits = defineEmits(['update:modelValue', 'focus-emoji-selector', 'focus-tabset', 'select-first-emoji']);\n\nconst searchInput = ref(null);\n\nfunction clearSearch () {\n  emits('update:modelValue', '');\n  focusSearchInput();\n}\n\nfunction focusSearchInput () {\n  searchInput.value.focus();\n}\nonMounted(() => {\n  focusSearchInput();\n});\n\ndefineExpose({\n  focusSearchInput,\n});\n</script>\n","export const CDN_URL = 'https://static.dialpadcdn.com/joypixels/png/unicode/32/';\nexport const EMOJIS_PER_ROW = 9;\nexport const EMOJI_SKIN_TONE_MODIFIERS = {\n  DEFAULT: 'Default',\n  LIGHT: 'Light',\n  MEDIUM_LIGHT: 'MediumLight',\n  MEDIUM: 'Medium',\n  MEDIUM_DARK: 'MediumDark',\n  DARK: 'Dark',\n};\n\nexport const EMOJI_CATEGORIES = {\n  MOST_RECENTLY_USED: 'Most recently used',\n  SMILEYS_AND_PEOPLE: 'Smileys and people',\n  NATURE: 'Nature',\n  FOOD: 'Food',\n  ACTIVITY: 'Activity',\n  TRAVEL: 'Travel',\n  OBJECTS: 'Objects',\n  SYMBOLS: 'Symbols',\n  FLAGS: 'Flags',\n};\n","<template>\n  <div class=\"d-emoji-picker__tabset\">\n    <dt-tab-group\n      tab-list-class=\"d-emoji-picker__tabset-list\"\n      :selected=\"selectedTab\"\n    >\n      <template #tabs>\n        <dt-tab\n          v-for=\"(tab, index) in tabs\"\n          :id=\"tab.id\"\n          :ref=\"el => { if (el) setTabsetRef(el) }\"\n          :key=\"tab.id\"\n          :panel-id=\"tab.panelId\"\n          :label=\"tab.label\"\n          aria-controls=\"d-emoji-picker-list\"\n          :tabindex=\"index + 1\"\n          @click.capture.stop=\"selectTabset(tab.id)\"\n          @keydown=\"handleKeyDown($event, tab.id)\"\n        >\n          <dt-icon\n            size=\"400\"\n            :name=\"tab.icon\"\n          />\n        </dt-tab>\n      </template>\n    </dt-tab-group>\n  </div>\n</template>\n\n<script setup>\nimport DtTabGroup from '@/components/tabs/tab_group.vue';\nimport DtTab from '@/components/tabs/tab.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { computed, ref, toRefs, watch } from 'vue';\nimport { EMOJI_CATEGORIES } from '@/components/emoji_picker/emoji_picker_constants';\n\nconst props = defineProps({\n  /**\n   * Whether to show the recently used tab or not\n   * @type {Boolean}\n   * @default false\n   */\n  showRecentlyUsedTab: {\n    type: Boolean,\n    default: false,\n  },\n\n  scrollIntoTab: {\n    type: Number,\n    required: true,\n  },\n\n  isScrolling: {\n    type: Boolean,\n    default: false,\n  },\n\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The labels for the aria-label\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when a tab is selected\n   * @event selected-tabset\n   * @param {String} tabId - The name of the tab that was selected\n   */\n  'selected-tabset',\n\n  'focus-search-input',\n]);\n\nconst TABS_DATA = [\n  { label: EMOJI_CATEGORIES.MOST_RECENTLY_USED, icon: 'clock' },\n  { label: EMOJI_CATEGORIES.SMILEYS_AND_PEOPLE, icon: 'satisfied' },\n  { label: EMOJI_CATEGORIES.NATURE, icon: 'living-thing' },\n  { label: EMOJI_CATEGORIES.FOOD, icon: 'food' },\n  { label: EMOJI_CATEGORIES.ACTIVITY, icon: 'object' },\n  { label: EMOJI_CATEGORIES.TRAVEL, icon: 'transportation' },\n  { label: EMOJI_CATEGORIES.OBJECTS, icon: 'lightbulb' },\n  { label: EMOJI_CATEGORIES.SYMBOLS, icon: 'heart' },\n  { label: EMOJI_CATEGORIES.FLAGS, icon: 'flag' },\n];\n\nconst tabs = computed(() => {\n  const tabsData = props.showRecentlyUsedTab ? TABS_DATA : TABS_DATA.slice(1);\n\n  return tabsData.map((tab, index) => ({\n    ...tab,\n    label: props.tabsetLabels[index],\n    id: (index + 1).toString(),\n    panelId: (index + 1).toString(),\n  }));\n});\n\nconst isSearching = computed(() => props.emojiFilter.length > 0);\n\nconst selectedTab = ref('1');\n\nconst { isScrolling } = toRefs(props);\n\nconst tabsetRef = ref([]);\n\nwatch(() => props.scrollIntoTab,\n  () => {\n    if (!isScrolling.value && !isSearching.value) {\n      selectedTab.value = (props.scrollIntoTab + 1).toString();\n    }\n  });\n\nwatch(isSearching,\n  () => {\n    if (isSearching.value) {\n      selectedTab.value = null;\n    }\n  });\n\n/**\n * We are using .capture.stop modifiers on the click event\n * because we don't want to trigger the click event of the\n * dt-tab component\n */\nfunction selectTabset (id) {\n  if (!isScrolling.value) {\n    selectedTab.value = id;\n  }\n  emits('selected-tabset', id);\n}\n\nfunction setTabsetRef (ref) {\n  // We push the $el, because $el is the button inside the dt-tab component\n  // and we need the button to focus it\n  tabsetRef.value.push(ref.$el);\n}\n\nfunction focusTabset () {\n  tabsetRef.value[0].focus();\n}\n\nfunction handleKeyDown (event, tabId) {\n  if (event.key === 'Enter') {\n    selectTabset(tabId);\n    // We blur because seems like the tab component override the selected prop, and it removes the selected style\n    tabsetRef.value[tabId - 1].blur();\n  }\n\n  if (event.key === 'Tab') {\n    event.preventDefault();\n    emits('focus-search-input');\n  }\n\n  if (event.key === 'ArrowDown') {\n    // Jump to search input\n    emits('focus-search-input');\n  }\n}\n\ndefineExpose({\n  focusTabset,\n});\n</script>\n","import { ref } from 'vue';\n\nexport function useKeyboardNavigation (emits) {\n  const emojiRefs = ref([]);\n  const emojiFilteredRefs = ref([]);\n\n  const isFiltering = ref(false);\n\n  const hoverFirstEmoji = ref(true);\n\n  function hoverEmoji (emoji, isFirst = false) {\n    hoverFirstEmoji.value = isFirst;\n    emits('highlighted-emoji', emoji);\n  }\n  function setEmojiRef (el, indexTab, indexEmoji) {\n    if (!emojiRefs.value[indexTab]) {\n      emojiRefs.value[indexTab] = [];\n    }\n    emojiRefs.value[indexTab][indexEmoji] = el;\n  }\n\n  function setFilteredRef (el, index) {\n    emojiFilteredRefs.value[index] = el;\n  }\n\n  function focusEmoji (indexTab, indexEmoji) {\n    const emojiRef = isFiltering.value ? emojiFilteredRefs.value?.[indexEmoji] : emojiRefs.value?.[indexTab]?.[indexEmoji];\n\n    if (emojiRef) {\n      emojiRef.focus();\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleArrowLeft (indexTab, indexEmoji) {\n    if (!focusEmoji(indexTab, indexEmoji - 1)) {\n      if (emojiRefs.value[indexTab - 1]) {\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      } else {\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n    }\n  }\n\n  function handleArrowRight (indexTab, indexEmoji) {\n    if (!focusEmoji(indexTab, indexEmoji + 1)) {\n      if (!focusEmoji(indexTab + 1, 0)) {\n        focusEmoji(0, 0);\n      }\n    }\n  }\n\n  function handleArrowLeftFiltered (indexTab, indexEmoji) {\n    if (!focusEmoji(0, indexEmoji - 1)) {\n      focusEmoji(0, emojiFilteredRefs.value.length - 1);\n    }\n  }\n\n  function handleArrowRightFiltered (indexTab, indexEmoji) {\n    if (!focusEmoji(0, indexEmoji + 1)) {\n      focusEmoji(0, 0);\n    }\n  }\n\n  function handleHorizontalNavigation (direction, indexTab, indexEmoji) {\n    if (isFiltering.value) {\n      if (direction === 'left') {\n        handleArrowLeftFiltered(indexTab, indexEmoji);\n      } else if (direction === 'right') {\n        handleArrowRightFiltered(indexTab, indexEmoji);\n      }\n    } else {\n      if (direction === 'left') {\n        handleArrowLeft(indexTab, indexEmoji);\n      } else if (direction === 'right') {\n        handleArrowRight(indexTab, indexEmoji);\n      }\n    }\n  }\n\n  return {\n    emojiRefs,\n    emojiFilteredRefs,\n    isFiltering,\n    hoverFirstEmoji,\n    setEmojiRef,\n    setFilteredRef,\n    hoverEmoji,\n    focusEmoji,\n    handleHorizontalNavigation,\n  };\n}\n","<template>\n  <div\n    class=\"d-emoji-picker__selector\"\n  >\n    <div\n      id=\"d-emoji-picker-list\"\n      ref=\"listRef\"\n      class=\"d-emoji-picker__list\"\n    >\n      <p\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__search-label d-emoji-picker__alignment\"\n      >\n        {{ filteredEmojis.length > 0 ? searchResultsLabel : searchNoResultsLabel }}\n      </p>\n      <div\n        v-else\n        ref=\"tabCategoryRef\"\n        class=\"d-emoji-picker__category d-emoji-picker__alignment\"\n      >\n        <p>\n          {{ fixedLabel }}\n        </p>\n      </div>\n      <div\n        v-for=\"(tabLabel, indexTab) in tabLabels\"\n        v-show=\"!emojiFilter\"\n        :key=\"indexTab\"\n        :ref=\"tabLabel.ref\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <p\n          v-if=\"indexTab\"\n        >\n          {{ tabLabel.label }}\n        </p>\n        <div\n          class=\"d-emoji-picker__tab\"\n        >\n          <button\n            v-for=\"(emoji, indexEmoji) in\n            (emojis[tabs[indexTab] + skinTone] ? emojis[tabs[indexTab] + skinTone] : emojis[tabs[indexTab]])\"\n            :key=\"emoji.shortname\"\n            :ref=\"el => { if (el) setEmojiRef(el, indexTab, indexEmoji) }\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"$emit('highlighted-emoji', emoji)\"\n            @mouseleave=\"$emit('highlighted-emoji', null)\"\n            @keydown=\"event => handleKeyDown(event, indexTab, indexEmoji, emoji)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"getImgSrc(emoji.unicode_character)\"\n              @error=\"handleImageError\"\n            >\n          </button>\n        </div>\n      </div>\n      <div\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <div\n          class=\"d-emoji-picker__tab \"\n          data-qa=\"filtered-emojis\"\n        >\n          <button\n            v-for=\"(emoji, index) in filteredEmojis\"\n            :key=\"emoji.shortname\"\n            :ref=\"el => { if (el) setFilteredRef(el, index) }\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            :class=\"{\n              'hover-emoji': (index === 0 && hoverFirstEmoji),\n            }\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"hoverEmoji(emoji)\"\n            @mouseleave=\"hoverEmoji(null)\"\n            @keydown=\"event => handleKeyDownFilteredEmojis(event, index, emoji)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"`${CDN_URL + emoji.unicode_character}.png`\"\n            >\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\n// eslint-disable max-len\nimport { emojisGrouped as emojis } from '@/components/emoji_picker/emojis';\nimport { computed, onMounted, onUnmounted, ref, watch, nextTick } from 'vue';\nimport { CDN_URL, EMOJIS_PER_ROW } from '@/components/emoji_picker/emoji_picker_constants';\nimport { useKeyboardNavigation } from '@/components/emoji_picker/composables/useKeyboardNavigation';\n\nconst props = defineProps({\n  /**\n   * The filter to apply to the emoji list\n   * @type {String}\n   * @default ''\n   */\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The labels for the tabset\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  selectedTabset: {\n    type: Object,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of recently used emojis\n   * @type {Array}\n   */\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => [],\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when the user hover over an emoji\n   * @event highlighted-emoji\n   * @param {Object} emoji - The emoji data that was hovered\n    */\n  'highlighted-emoji',\n\n  /**\n   * Emitted when the user select an emoji\n   * @event selected-emoji\n   * @param {Object} emoji - The emoji data that was selected\n    */\n  'selected-emoji',\n\n  /**\n   * Emitted when the user scroll into an emoji tab\n   * @event scroll-into-tab\n   * @param {Number} tab-index - The tab that was scrolled into\n    */\n  'scroll-into-tab',\n\n  /**\n   * Emitted when the scrollTo function starts scrolling and stops scrolling\n   * @event is-scrolling\n   * @param {Boolean} is-scrolling - Whether the user is scrolling with the scroll-to\n    */\n  'is-scrolling',\n\n  /**\n   * Emitted when the user reach the end of the emoji list\n   * @event focus-skin-selector\n    */\n  'focus-skin-selector',\n\n  /**\n   * Emitted when the user shift tab in first tab of emoji selector\n   * @event focus-search-input\n    */\n  'focus-search-input',\n]);\n\nconst {\n  emojiRefs,\n  emojiFilteredRefs,\n  isFiltering,\n  hoverFirstEmoji,\n  setEmojiRef,\n  setFilteredRef,\n  hoverEmoji,\n  focusEmoji,\n  handleHorizontalNavigation,\n} = useKeyboardNavigation(emits);\n\n/**\n * The ref for the tab category\n * This is used to display the fixed label\n */\nconst tabCategoryRef = ref(null);\n\n/**\n * The ref for the list\n * This is used to display the tabs\n */\nconst listRef = ref(null);\n\n/**\n * The ref for the tab label observer\n * This is used to update the fixed label\n */\nconst tabLabelObserver = ref(null);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n */\nconst TABS_DATA = ['Recently used', 'People', 'Nature', 'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags'];\n\n/**\n * The list of tab labels\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n */\nconst tabLabels = computed(() => {\n  return props.recentlyUsedEmojis.length\n    ? props.tabsetLabels.map((label) => ({ label, ref: ref(null) }))\n    : props.tabsetLabels.slice(1).map((label) => ({ label, ref: ref(null) }));\n});\n\n/**\n * The label of the fixed tab\n * This is used to display the fixed label\n */\nconst fixedLabel = ref(tabLabels.value[0].label);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n * The difference between this and the tab labels is that this one will set the structure of tabs\n * and the tab labels will set the labels\n */\nconst tabs = computed(() => {\n  return props.recentlyUsedEmojis.length ? TABS_DATA : TABS_DATA.slice(1);\n});\n\n/**\n * The list of current emojis that match the filter\n * This will be updated when the emojiFilter changes\n * This is used to display the search results\n * The difference between this and the current emojis list is that this one will not have the skin tone applied\n */\nconst filteredEmojis = ref([]);\n\n/**\n * The current emojis list we are displaying\n * This will be updated when the skin tone changes\n * The difference between this and the emojis list is that this one will have only the skin tone applied\n */\nconst currentEmojis = computed(() => {\n  return [\n    ...emojis[`People${props.skinTone}`],\n    ...emojis.Nature,\n    ...emojis.Food,\n    ...emojis[`Activity${props.skinTone}`],\n    ...emojis.Travel,\n    ...emojis[`Objects${props.skinTone}`],\n    ...emojis.Symbols,\n    ...emojis.Flags,\n  ];\n});\n\n/**\n * This will trigger the searchByNameAndKeywords function with debounce of 300 milliseconds\n */\nconst debouncedSearch = debounce(() => {\n  // We clean the emojiFilteredRefs to have an updated ref list for the search results\n  emojiFilteredRefs.value = [];\n  searchByNameAndKeywords();\n});\n\n/**\n * Update the current emojis list on skin tone changes\n * Also update the filtered emojis list\n * @listens skinTone\n */\nwatch(currentEmojis, () => {\n  searchByNameAndKeywords();\n}, { immediate: true });\n\n/**\n * Update the recently used emojis list on recently used emojis prop changes\n * @listens recentlyUsedEmojis\n */\nwatch(() => props.recentlyUsedEmojis,\n  () => {\n    emojis['Recently used'] = props.recentlyUsedEmojis;\n  }, { immediate: true });\n\n/**\n * Search for emojis by name and keywords\n * Will update the filtered emojis list on emojiFilter update\n * @listens emojiFilter\n */\nwatch(() => props.emojiFilter, () => {\n  resetScroll();\n  if (props.emojiFilter) {\n    isFiltering.value = true;\n  } else {\n    isFiltering.value = false;\n    // If the emoji filter is empty, emit null to remove the highlighted emoji\n    // of the previous search\n    emits('highlighted-emoji', null);\n  }\n  debouncedSearch();\n});\n\nwatch(\n  () => props.selectedTabset,\n  (tab) => {\n    scrollToTab(tab.tabId);\n  },\n  { deep: true },\n);\n\n/**\n * Filters an array of emoji objects based on a search string that matches both the name and keywords.\n * Will update the filtered emojis list\n */\nfunction searchByNameAndKeywords () {\n  const searchStr = props.emojiFilter.toLowerCase();\n  filteredEmojis.value = currentEmojis.value.filter(obj => {\n    const nameIncludesSearchStr = obj.name.toLowerCase().includes(searchStr);\n    const keywordsIncludeSearchStr = obj.keywords.some(keyword => keyword.toLowerCase().includes(searchStr));\n    return nameIncludesSearchStr || keywordsIncludeSearchStr;\n  });\n  nextTick(() => {\n    if (searchStr) {\n      hoverEmoji(filteredEmojis.value[0], true);\n    }\n  });\n}\n\nfunction debounce (fn, delay = 300) {\n  let timeout;\n\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), delay);\n  };\n}\n\nfunction getImgSrc (emoji) {\n  return `${CDN_URL + emoji}.png`;\n}\n\n/**\n * Handle image error - We hide the entire button if the image is not found\n */\nfunction handleImageError (event) {\n  event.target.parentNode.style.display = 'none';\n}\n\n/**\n * Scroll to the selected tab\n */\nfunction scrollToTab (tabIndex, focusFirstEmoji = true) {\n  const tabLabel = tabLabels.value[tabIndex - 1];\n  const tabElement = tabLabel.ref.value[0];\n\n  nextTick(() => {\n    const container = listRef.value;\n    const offsetTop = tabIndex === '1' ? 0 : tabElement.offsetTop - 20;\n\n    /**\n     * This variable is used to check if the user is scrolling inside the emoji picker\n     * This is used to check if the user is scrolling using the scrollTo function\n     * This is useful because this flag will prevent to update the fixed label when the user is scrolling\n     * using the scrollTo function\n     */\n    let isScrolling = true;\n\n    let prevScrollTop = container.scrollTop;\n    emits('is-scrolling', true);\n\n    /**\n     * This event listener checks whether the user is scrolling up or down by comparing the current scrollTop\n     * to prevScrollTop. If the scrollToTab function is scrolling from bottom to top and has reached the desired\n     * position (scrollTop <= offsetTop),or if the scrollToTab function is scrolling from top to bottom and has\n     * passed the desired position(scrollTop >= offsetTop), then isScrolling is set to false.\n     */\n    container.addEventListener('scroll', () => {\n      if (isScrolling) {\n        const scrollTop = container.scrollTop;\n        if (\n          (prevScrollTop < scrollTop && scrollTop >= offsetTop) ||\n          (prevScrollTop > scrollTop && scrollTop <= offsetTop)\n        ) {\n          isScrolling = false;\n          emits('is-scrolling', false);\n        }\n        prevScrollTop = scrollTop;\n      }\n    });\n\n    container.scrollTop = offsetTop;\n\n    if (focusFirstEmoji) {\n      focusEmoji((tabIndex - 1), 0);\n    }\n  });\n}\n\nfunction resetScroll () {\n  const container = listRef.value;\n\n  container.scrollTop = 0;\n}\n\n/**\n * This code creates an IntersectionObserver object that monitors the intersection between\n * the root element (tabCategoryRef) and its targets (the child elements of listRef),\n * and updates the value of the fixedLabel variable accordingly.\n */\nfunction setTabLabelObserver () {\n  /**\n   * The code extracts the target element and its index from the IntersectionObserverEntry object,\n   * and checks whether the target intersects with the root and is positioned above or below it.\n   */\n  tabLabelObserver.value = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const { target } = entry;\n      const index = parseInt(target.dataset.index);\n\n      /**\n       * If the target is positioned above the root,\n       * the code updates the value of the fixed label to the label of the previous tab,\n       * or the first tab if the current tab is the first one. If the target is positioned below the root, the code\n       * updates the value of the fixed label to the label of the current tab.\n       * If the target stops intersecting with the root and its index is 1 (the second tab),\n       * the code updates the value of the fixed label to the label of the first tab.\n       * NOTES:\n       * This last condition is needed because sometimes it is\n       * not detect the intersection between the root and the target.\n       * We also provide a 50 pixels offset to the root element in the first condition to always get the\n       * first tab if it has fewer emojis, because in some cases if you quickly scroll the observer does not detect it.\n       */\n      if (entry.isIntersecting && target.offsetTop <= tabCategoryRef.value.offsetTop + 50) {\n        fixedLabel.value = tabLabels.value[index - 1]?.label ?? tabLabels.value[0]?.label;\n        emits('scroll-into-tab', index - 1);\n      } else if (entry.boundingClientRect.bottom <= tabCategoryRef.value?.getBoundingClientRect().bottom) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[index]?.label;\n      } else if (index === 1) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[0]?.label;\n      }\n    });\n  });\n\n  /**\n   * The tabLabelObserver is set to observe the root element and all its children elements with\n   * the IntersectionObserver object, and sets their data-index attribute to their index.\n   */\n  tabLabelObserver.value.observe(tabCategoryRef.value);\n\n  Array.from(listRef.value.children).forEach((child, index) => {\n    tabLabelObserver.value.observe(child);\n    child.dataset.index = index;\n  });\n}\n\nconst handleKeyDownFilteredEmojis = (event, indexEmoji, emoji) => {\n  event.preventDefault();\n  hoverFirstEmoji.value = false;\n\n  if (event.key === 'ArrowUp') {\n    const position = indexEmoji % EMOJIS_PER_ROW;\n\n    if (!focusEmoji(0, indexEmoji - EMOJIS_PER_ROW)) {\n      const lastEmojiPosition =\n        emojiFilteredRefs.value.length - (emojiFilteredRefs.value.length % EMOJIS_PER_ROW) + position;\n\n      focusEmoji(0, lastEmojiPosition);\n\n      if (!focusEmoji(0, lastEmojiPosition)) {\n        focusEmoji(0, emojiFilteredRefs.value.length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowDown') {\n    if (!focusEmoji(0, indexEmoji + EMOJIS_PER_ROW)) {\n      const position = indexEmoji % EMOJIS_PER_ROW;\n\n      if (emojiFilteredRefs.value?.[indexEmoji + (EMOJIS_PER_ROW - position)]) {\n        focusEmoji(0, emojiFilteredRefs.value.length - 1);\n      } else {\n        focusEmoji(0, position);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowLeft') {\n    handleHorizontalNavigation('left', 0, indexEmoji);\n  }\n\n  if (event.key === 'ArrowRight') {\n    handleHorizontalNavigation('right', 0, indexEmoji);\n  }\n\n  if (event.key === 'Tab') {\n    emits('focus-skin-selector');\n  }\n\n  if (event.key === 'Enter') {\n    emits('selected-emoji', emoji);\n  }\n};\n\nconst handleKeyDown = (event, indexTab, indexEmoji, emoji) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowUp') {\n    const position = indexEmoji % EMOJIS_PER_ROW;\n\n    if (indexTab === 0) {\n      // we are on the first emoji tab, then we should jump to the last row of the last emoji tab\n      const numberOfMissingEmojis =\n        EMOJIS_PER_ROW - (emojiRefs.value[emojiRefs.value.length - 1].length % EMOJIS_PER_ROW);\n\n      const emojiToJump =\n        emojiRefs.value[emojiRefs.value.length - 1].length + numberOfMissingEmojis - (EMOJIS_PER_ROW - position);\n\n      if (!focusEmoji(emojiRefs.value.length - 1, emojiToJump)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n      return;\n    }\n\n    // if we are not on the first tab, we should jump to the previous row of the current tab\n    if (!focusEmoji(indexTab, indexEmoji - EMOJIS_PER_ROW)) {\n      // if there is no previous row, we should jump to emoji in the sampe position of the previous tab\n      const previousTab = indexTab - 1 < 0 ? 0 : indexTab - 1;\n      const emojisInPreviousTab = emojiRefs.value[previousTab].length;\n      const lastEmojiPosition = emojisInPreviousTab - (emojisInPreviousTab % EMOJIS_PER_ROW) + position;\n\n      if (!focusEmoji(previousTab, lastEmojiPosition)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowDown') {\n    if (!focusEmoji(indexTab, indexEmoji + EMOJIS_PER_ROW)) {\n      // if cannot go down\n\n      // Calculate position from cell 0 to cell 8\n      const position = indexEmoji % EMOJIS_PER_ROW;\n\n      // check if it exists a next row in the current tab\n      if (emojiRefs.value?.[indexTab]?.[indexEmoji + (EMOJIS_PER_ROW - position)]) {\n        // if it exists, we should focus the last emoji of the next row in the current tab\n        focusEmoji(indexTab, emojiRefs.value[indexTab].length - 1);\n        // if we are at the end of the list it will do nothing\n      } else {\n        // We don't have next row, we are in the last of the tab, then jump\n        // to the next tab but in the equal emoji position in row 0.\n\n        if (!focusEmoji(indexTab + 1, position)) {\n          // We are on the bottom!, should jump to the same position emoji in the first row of the first tabset\n          // if it doesn't has, jump to the last\n          if (!focusEmoji(0, position)) {\n            focusEmoji(0, emojiRefs.value[0].length - 1);\n          }\n        }\n      }\n    }\n  }\n\n  if (event.key === 'ArrowLeft') {\n    handleHorizontalNavigation('left', indexTab, indexEmoji);\n  }\n\n  if (event.key === 'ArrowRight') {\n    handleHorizontalNavigation('right', indexTab, indexEmoji);\n  }\n\n  if (event.key === 'Tab') {\n    if (focusEmoji(indexTab + 1, 0)) {\n      scrollToTab((indexTab + 1) + 1, false);\n    } else {\n      // We are on the last emoji tabset, jump to the skin selector\n      emits('focus-skin-selector');\n    }\n  }\n\n  if (event.key === 'Tab' && event.shiftKey) {\n    if (focusEmoji(indexTab, 0) && indexTab > 0) {\n      scrollToTab(indexTab, true);\n    } else {\n      scrollToTab(1, false);\n      emits('focus-search-input');\n    }\n  }\n\n  if (event.key === 'Enter') {\n    emits('selected-emoji', emoji);\n  }\n};\n\nfunction focusEmojiSelector () {\n  focusEmoji(0, 0);\n}\n\nonMounted(() => {\n  setTabLabelObserver();\n});\n\nonUnmounted(() => {\n  tabLabelObserver.value.disconnect();\n});\n\ndefineExpose({\n  focusEmojiSelector,\n});\n</script>\n","<template>\n  <div data-qa=\"skin-selector\">\n    <div\n      v-show=\"isOpen\"\n      class=\"d-emoji-picker__skin-list\"\n    >\n      <button\n        v-for=\"(skin, index) in skinList\"\n        :ref=\"el => { if (el) setSkinsRef(el) }\"\n        :key=\"skin.name\"\n        :class=\"{\n          'selected': skinSelected.skinCode === skin.skinCode,\n        }\"\n        @keydown=\"event => handleKeyDown(event, skin, index)\"\n        @click=\"selectSkin(skin)\"\n      >\n        <img\n          class=\"d-icon d-icon--size-500\"\n          :alt=\"skin.name\"\n          :aria-label=\"skin.name\"\n          :title=\"skin.name\"\n          :src=\"`${CDN_URL + skin.unicode_output}.png`\"\n        >\n      </button>\n    </div>\n    <div\n      v-show=\"!isOpen\"\n      class=\"d-emoji-picker__skin-selected\"\n    >\n      <dt-tooltip placement=\"top-end\">\n        {{ skinSelectorButtonTooltipLabel }}\n        <template #anchor>\n          <button\n            ref=\"skinSelectorRef\"\n            :aria-label=\"skinSelectorButtonTooltipLabel\"\n            tabindex=\"-1\"\n            @click=\"toggleSkinList\"\n            @keydown=\"event => handleKeyDown(event)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"skinSelected.name\"\n              :aria-label=\"skinSelected.name\"\n              :title=\"skinSelected.name\"\n              :src=\"`${CDN_URL + skinSelected.unicode_output}.png`\"\n            >\n          </button>\n        </template>\n      </dt-tooltip>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { computed, nextTick, ref, watchEffect } from 'vue';\nimport { CDN_URL, EMOJI_SKIN_TONE_MODIFIERS } from '@/components/emoji_picker/emoji_picker_constants';\nimport { DtTooltip } from '@/components/tooltip';\n\nconst props = defineProps({\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  isHovering: {\n    type: Boolean,\n    default: false,\n  },\n\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * The skin tone that was selected\n   * @event skin-tone\n   * @type {Number}\n   */\n  'skin-tone',\n  'focus-tabset',\n]);\n\nconst skinList = [\n  {\n    name: ':wave_tone1:',\n    unicode_output: '1f44b-1f3fb',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.LIGHT,\n    skinCode: '_tone1',\n  },\n  {\n    name: ':wave_tone2:',\n    unicode_output: '1f44b-1f3fc',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.MEDIUM_LIGHT,\n    skinCode: '_tone2',\n  },\n  {\n    name: ':wave_tone3:',\n    unicode_output: '1f44b-1f3fd',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.MEDIUM,\n    skinCode: '_tone3',\n  },\n  {\n    name: ':wave_tone4:',\n    unicode_output: '1f44b-1f3fe',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.MEDIUM_DARK,\n    skinCode: '_tone4',\n  },\n  {\n    name: ':wave_tone5:',\n    unicode_output: '1f44b-1f3ff',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.DARK,\n    skinCode: '_tone5',\n  },\n  {\n    name: ':wave:',\n    unicode_output: '1f44b',\n    skinTone: EMOJI_SKIN_TONE_MODIFIERS.DEFAULT,\n    skinCode: '',\n  },\n];\n\nconst isOpen = ref(false);\n\nconst skinSelectorRef = ref(null);\n\nconst skinsRef = ref([]);\n\n/**\n * It will close the skin selector if the user is hovering over the emoji list\n */\nwatchEffect(\n  () => props.isHovering && (isOpen.value = false),\n);\n\n/**\n * It will initially display props.skinTone. If a new skin tone is selected,\n * it will display that until props.skinTone changes.\n */\nconst skinPassedIn = computed(() => skinList.find((skin) => skin.skinTone === props.skinTone));\nconst skinSelected = ref(skinPassedIn.value);\nwatchEffect(() => skinPassedIn.value && (skinSelected.value = skinPassedIn.value));\n\nfunction setSkinsRef (ref) {\n  skinsRef.value.push(ref);\n}\nfunction focusSkinSelector () {\n  skinSelectorRef.value.focus();\n}\n\nfunction selectSkin (skin) {\n  skinSelected.value = skin;\n  isOpen.value = false;\n  emits('skin-tone', skin.skinTone);\n  nextTick(() => focusSkinSelector());\n}\n\nconst handleKeyDown = (event, skin, index) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowLeft') {\n    if (index === 0) skinsRef.value[skinsRef.value.length - 1]?.focus();\n    skinsRef.value[index - 1]?.focus();\n  }\n\n  if (event.key === 'ArrowRight') {\n    skinsRef.value[index + 1]?.focus();\n  }\n\n  if (event.key === 'Enter') {\n    if (skin) { selectSkin(skin); } else {\n      toggleSkinList();\n    }\n  }\n\n  if (event.key === 'Tab') {\n    emits('focus-tabset');\n  }\n};\n\nfunction toggleSkinList () {\n  isOpen.value = !isOpen.value;\n  nextTick(() => skinsRef.value[0].focus());\n}\n\ndefineExpose({\n  focusSkinSelector,\n});\n</script>\n","<template>\n  <div\n    class=\"d-emoji-picker\"\n  >\n    <div class=\"d-emoji-picker--header\">\n      <emoji-tabset\n        ref=\"tabsetRef\"\n        :emoji-filter=\"searchQuery\"\n        :show-recently-used-tab=\"showRecentlyUsedTab\"\n        :scroll-into-tab=\"scrollIntoTab\"\n        :tabset-labels=\"tabSetLabels\"\n        :is-scrolling=\"isScrolling\"\n        @focus-search-input=\"$refs.searchInputRef.focusSearchInput()\"\n        @selected-tabset=\"scrollToSelectedTabset\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--body\">\n      <emoji-search\n        ref=\"searchInputRef\"\n        v-model=\"searchQuery\"\n        :search-placeholder-label=\"searchPlaceholderLabel\"\n        @select-first-emoji=\"emits('selected-emoji', highlightedEmoji)\"\n        @focus-tabset=\"$refs.tabsetRef.focusTabset()\"\n        @focus-emoji-selector=\"$refs.emojiSelectorRef.focusEmojiSelector()\"\n        @keydown.esc=\"emits('close')\"\n      />\n      <emoji-selector\n        ref=\"emojiSelectorRef\"\n        :emoji-filter=\"searchQuery\"\n        :skin-tone=\"skinTone\"\n        :tabset-labels=\"tabSetLabels\"\n        :search-results-label=\"searchResultsLabel\"\n        :search-no-results-label=\"searchNoResultsLabel\"\n        :recently-used-emojis=\"recentlyUsedEmojis\"\n        :selected-tabset=\"selectedTabset\"\n        @scroll-into-tab=\"updateScrollIntoTab\"\n        @is-scrolling=\"updateIsScrolling\"\n        @highlighted-emoji=\"updateHighlightedEmoji\"\n        @selected-emoji=\"emits('selected-emoji', $event)\"\n        @focus-skin-selector=\"$refs.skinSelectorRef.focusSkinSelector()\"\n        @focus-search-input=\"$refs.searchInputRef.focusSearchInput()\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--footer\">\n      <emoji-description :emoji=\"highlightedEmoji\" />\n      <emoji-skin-selector\n        ref=\"skinSelectorRef\"\n        :is-hovering=\"!!highlightedEmoji\"\n        :skin-selector-button-tooltip-label=\"skinSelectorButtonTooltipLabel\"\n        :skin-tone=\"skinTone\"\n        @skin-tone=\"emits('skin-tone', $event)\"\n        @focus-tabset=\"$refs.tabsetRef.focusTabset()\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport EmojiSearch from './modules/emoji_search.vue';\nimport EmojiTabset from './modules/emoji_tabset.vue';\nimport EmojiSelector from './modules/emoji_selector.vue';\nimport EmojiSkinSelector from './modules/emoji_skin_selector.vue';\nimport EmojiDescription from './modules/emoji_description.vue';\nimport { computed, ref } from 'vue';\n\nconst props = defineProps({\n  /**\n   * The array with recently used  emoji object\n   * This list is necessary to fill the recently used tab\n   * @type {Array}\n   * @default []\n   * @example\n   * <dt-emoji-picker :recentlyUsedEmojis=\"[emojiObject, emojiObject]\" />\n   */\n  // TODO try to simplify this to achieve an array of unicode characters and not an entire emoji data object\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => ([]),\n  },\n\n  /**\n   * The placeholder text for the search input\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchPlaceholderLabel=\"'Search...'\" />\n   */\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchResultsLabel=\"'Search results'\" />\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search no results\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchNoResultsLabel=\"'No results'\" />\n   */\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of tabsets to show, it is necessary to be updated with the correct language\n   * It must respect the provided order.\n   * @type {Array}\n   * @required\n   * @example\n   * <dt-emoji-picker\n   *  :tabSetLabels=\"['Most recently used', 'Smileys and people', 'Nature',\n   *    'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags']\" />\n   */\n  tabSetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  /**\n   * The skin tone to show the emojis\n   * This prop gives the possibility to use the skin tone selected by the user previously\n   * @type {String}\n   * @default 'Default'\n   * @values 'Default', 'Light', 'MediumLight', 'Medium', 'MediumDark', 'Dark'\n   * @example\n   * <dt-emoji-picker :skinTone=\"'Default'\" />\n   */\n  skinTone: {\n    type: String,\n    default: 'Default',\n  },\n\n  /**\n   * Tooltip shown when skin selector button is hovered.\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :skin-selector-button-tooltip-label=\"'Change default skin tone'\" />\n   */\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits(\n  [\n    /**\n     * It will emit the selected emoji\n     * @event selected-emoji\n     * @param {Object} emoji - The selected emoji from the emoji selector\n     */\n    'selected-emoji',\n\n    /**\n     * It will emit the selected skin tone\n     * @event skin-tone\n     * @param {String} skin - The selected skin tone from the skin selector\n     */\n    'skin-tone',\n\n    /**\n     * Since the keyboard events are encapsulated, we emit this event to close the picker\n     * @event close\n     */\n    'close',\n  ],\n);\n\nconst searchQuery = ref('');\nconst highlightedEmoji = ref(null);\nconst selectedTabset = ref({});\n\nconst scrollIntoTab = ref(0);\nconst isScrolling = ref(false);\n\nconst showRecentlyUsedTab = computed(() => props.recentlyUsedEmojis.length > 0);\n\n/**\n * Handle the selected tabset event\n * We're creating a new object with the same value as selectedTabset and assigning it back to selectedTabset.\n * Vue will see this as a new object and trigger the watcher in the child component.\n * Using this method, we are able to trigger the watcher in the child component even if the value being passed is the\n * same as the previous value.\n * @event selectedTabset\n * @param tabName {String} - The name of the tab that was selected\n */\nfunction scrollToSelectedTabset (tabId) {\n  searchQuery.value = '';\n  selectedTabset.value = tabId;\n  selectedTabset.value = { ...selectedTabset.value, tabId };\n}\n\nfunction updateScrollIntoTab (value) {\n  scrollIntoTab.value = value;\n}\n\nfunction updateIsScrolling (value) {\n  isScrolling.value = value;\n}\nfunction updateHighlightedEmoji (emoji) {\n  highlightedEmoji.value = emoji;\n}\n</script>\n"],"names":["searchInput","ref","clearSearch","emits","focusSearchInput","onMounted","__expose","CDN_URL","EMOJIS_PER_ROW","EMOJI_SKIN_TONE_MODIFIERS","EMOJI_CATEGORIES","TABS_DATA","tabs","computed","props","tab","index","isSearching","selectedTab","isScrolling","toRefs","tabsetRef","watch","selectTabset","id","setTabsetRef","focusTabset","handleKeyDown","event","tabId","useKeyboardNavigation","emojiRefs","emojiFilteredRefs","isFiltering","hoverFirstEmoji","hoverEmoji","emoji","isFirst","setEmojiRef","el","indexTab","indexEmoji","setFilteredRef","focusEmoji","emojiRef","_a","_c","_b","handleArrowLeft","handleArrowRight","handleArrowLeftFiltered","handleArrowRightFiltered","handleHorizontalNavigation","direction","tabCategoryRef","listRef","tabLabelObserver","tabLabels","label","fixedLabel","filteredEmojis","currentEmojis","emojis","debouncedSearch","debounce","searchByNameAndKeywords","resetScroll","scrollToTab","searchStr","obj","nameIncludesSearchStr","keywordsIncludeSearchStr","keyword","nextTick","fn","delay","timeout","args","getImgSrc","handleImageError","tabIndex","focusFirstEmoji","tabElement","container","offsetTop","prevScrollTop","scrollTop","setTabLabelObserver","entries","entry","target","_d","_e","child","handleKeyDownFilteredEmojis","position","lastEmojiPosition","numberOfMissingEmojis","emojiToJump","previousTab","emojisInPreviousTab","focusEmojiSelector","onUnmounted","skinList","isOpen","skinSelectorRef","skinsRef","watchEffect","skinPassedIn","skin","skinSelected","setSkinsRef","focusSkinSelector","selectSkin","toggleSkinList","searchQuery","highlightedEmoji","selectedTabset","scrollIntoTab","showRecentlyUsedTab","scrollToSelectedTabset","updateScrollIntoTab","value","updateIsScrolling","updateHighlightedEmoji"],"mappings":"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"}