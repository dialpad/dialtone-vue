{"version":3,"file":"emoji_picker.stories-ebfc777d.js","sources":["../../components/emoji_picker/modules/emoji_search.vue","../../components/emoji_picker/modules/emoji_tabset.vue","../../components/emoji_picker/emoji_picker_constants.js","../../components/emoji_picker/modules/emoji_selector.vue","../../components/emoji_picker/modules/emoji_skin_selector.vue","../../components/emoji_picker/emoji_picker.vue","../../components/emoji_picker/emoji_picker_default.story.vue"],"sourcesContent":["<template>\n  <div class=\"d-emoji-picker__search d-emoji-picker__alignment\">\n    <dt-input\n      ref=\"searchInput\"\n      :placeholder=\"searchPlaceholderLabel\"\n      :model-value=\"modelValue\"\n      @update:model-value=\"$emit('update:modelValue', $event)\"\n    >\n      <template #leftIcon>\n        <dt-icon name=\"search\" />\n      </template>\n      <template\n        v-if=\"modelValue.length > 0\"\n        #rightIcon\n      >\n        <button\n          class=\"d-emoji-picker__search-button\"\n        >\n          <dt-icon\n            name=\"close\"\n            @click=\"$emit('update:modelValue', '')\"\n          />\n        </button>\n      </template>\n    </dt-input>\n  </div>\n</template>\n\n<script setup>\nimport DtInput from '@/components/input/input.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { onMounted, ref } from 'vue';\n\ndefineEmits(['update:modelValue']);\ndefineProps({\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n});\n\nconst searchInput = ref(null);\n\nfunction focusSearchInput () {\n  searchInput.value.focus();\n}\nonMounted(() => {\n  focusSearchInput();\n});\n\ndefineExpose({\n  focusSearchInput,\n});\n</script>\n\n<style scoped>\n.d-emoji-picker__search {\n  position: relative;\n  z-index: 1;\n  margin: var(--su16) var(--su24) var(--su16) var(--su16);\n  background-color: #FFFFFF;\n}\n.d-emoji-picker__search-button{\n    border: none;\n    background: none;\n    cursor: pointer;\n    margin: 0;\n    padding: 0;\n    outline: none;\n    line-height: 0;\n}\n</style>\n","<template>\n  <div class=\"d-emoji-picker__tabset\">\n    <dt-tab-group\n      tab-list-class=\"d-emoji-picker__tabset-list\"\n      :selected=\"selectedTab\"\n    >\n      <template #tabs>\n        <dt-tab\n          v-for=\"(tab, index) in tabs\"\n          :id=\"tab.id\"\n          :ref=\"el => { if (el) setTabsetRef(el) }\"\n          :key=\"tab.id\"\n          :panel-id=\"tab.panelId\"\n          :label=\"tab.label\"\n          aria-controls=\"d-emoji-picker-list\"\n          :tabindex=\"index + 1\"\n          @click.capture.stop=\"selectTabset(tab.id)\"\n          @keydown.capture.stop=\"handleKeyDown($event, tab.id)\"\n        >\n          <dt-icon\n            size=\"400\"\n            :name=\"tab.icon\"\n          />\n        </dt-tab>\n      </template>\n    </dt-tab-group>\n  </div>\n</template>\n\n<script setup>\nimport DtTabGroup from '@/components/tabs/tab_group.vue';\nimport DtTab from '@/components/tabs/tab.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { computed, nextTick, ref, toRefs, watch } from 'vue';\n\nconst props = defineProps({\n  /**\n   * Whether to show the recently used tab or not\n   * @type {Boolean}\n   * @default false\n   */\n  showRecentlyUsedTab: {\n    type: Boolean,\n    default: false,\n  },\n\n  scrollIntoTab: {\n    type: Number,\n    required: true,\n  },\n\n  isScrolling: {\n    type: Boolean,\n    default: false,\n  },\n\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The labels for the aria-label\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when a tab is selected\n   * @event selected-tabset\n   * @param {String} tabId - The name of the tab that was selected\n   */\n  'selected-tabset',\n\n  'focus-search-input',\n]);\n\nconst TABS_DATA = [\n  { label: 'Recently used', icon: 'clock' },\n  { label: 'Smileyâ€™s and people', icon: 'satisfied' },\n  { label: 'Nature', icon: 'living-thing' },\n  { label: 'Food', icon: 'food' },\n  { label: 'Activity', icon: 'object' },\n  { label: 'Travel', icon: 'transportation' },\n  { label: 'Objects', icon: 'lightbulb' },\n  { label: 'Symbols', icon: 'heart' },\n  { label: 'Flags', icon: 'flag' },\n];\n\nconst tabs = computed(() => {\n  const tabsData = props.showRecentlyUsedTab ? TABS_DATA : TABS_DATA.slice(1);\n\n  return tabsData.map((tab, index) => ({\n    ...tab,\n    label: props.tabsetLabels[index],\n    id: (index + 1).toString(),\n    panelId: (index + 1).toString(),\n  }));\n});\n\nconst isSearching = computed(() => props.emojiFilter.length > 0);\n\nconst selectedTab = ref('1');\n\nconst { isScrolling } = toRefs(props);\n\nconst tabsetRef = ref([]);\n\nwatch(() => props.scrollIntoTab,\n  () => {\n    if (!isScrolling.value && !isSearching.value) {\n      selectedTab.value = (props.scrollIntoTab + 1).toString();\n    }\n  });\n\nwatch(isSearching,\n  () => {\n    if (isSearching.value) {\n      selectedTab.value = null;\n    }\n  });\n\n/**\n * We are using .capture.stop modifiers on the click event\n * because we don't want to trigger the click event of the\n * dt-tab component\n */\nfunction selectTabset (id) {\n  if (!isScrolling.value) {\n    selectedTab.value = id;\n  }\n  emits('selected-tabset', id);\n}\n\nfunction setTabsetRef (ref) {\n  // We push the $el, because $el is the button inside the dt-tab component\n  // and we need the button to focus it\n  tabsetRef.value.push(ref.$el);\n}\n\nfunction focusTabset () {\n  tabsetRef.value[0].focus();\n}\n\nfunction handleKeyDown (event, tabId) {\n  if (event.key === 'Enter') {\n    selectTabset(tabId);\n    // We blur because seems like the tab component override the selected prop, and it removes the selected style\n    tabsetRef.value[tabId - 1].blur();\n  }\n\n  if (event.key === 'ArrowDown') {\n    selectTabset(tabId);\n    // Jump to search input\n    emits('focus-search-input');\n  }\n}\n\ndefineExpose({\n  focusTabset,\n});\n</script>\n\n<style lang=\"less\">\n.d-emoji-picker{\n  &__tabset-list{\n      gap: 4px;\n\n      &::after{\n        background-color: var(--black-200) !important;\n      }\n\n      button{\n        padding: var(--space-400);\n\n        &.d-tab--selected{\n          &::after{\n            height: var(--size-200);\n          }\n        }\n    }\n  }\n}\n</style>\n","export const CDN_URL = 'https://static.dialpadcdn.com/joypixels/png/unicode/32/';\nexport const EMOJIS_PER_ROW = 9;\n","<template>\n  <div\n    class=\"d-emoji-picker__selector\"\n  >\n    <div\n      id=\"d-emoji-picker-list\"\n      ref=\"listRef\"\n      class=\"d-emoji-picker__list\"\n    >\n      <p\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__search-label d-emoji-picker__alignment\"\n      >\n        {{ filteredEmojis.length > 0 ? searchResultsLabel : searchNoResultsLabel }}\n      </p>\n      <div\n        v-else\n        ref=\"tabCategoryRef\"\n        class=\"d-emoji-picker__category d-emoji-picker__alignment\"\n      >\n        <p>\n          {{ fixedLabel }}\n        </p>\n      </div>\n      <div\n        v-for=\"(tabLabel, indexTab) in tabLabels\"\n        v-show=\"!emojiFilter\"\n        :key=\"indexTab\"\n        :ref=\"tabLabel.ref\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <p\n          v-if=\"indexTab\"\n        >\n          {{ tabLabel.label }}\n        </p>\n        <div\n          class=\"d-emoji-picker__tab\"\n        >\n          <button\n            v-for=\"(emoji, indexEmoji) in (emojis[tabs[indexTab] + skinTone] ? emojis[tabs[indexTab] + skinTone] : emojis[tabs[indexTab]])\"\n            :key=\"emoji.shortname\"\n            :ref=\"el => { if (el) setEmojiRef(el, indexTab, indexEmoji) }\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"$emit('highlighted-emoji', emoji)\"\n            @mouseleave=\"$emit('highlighted-emoji', null)\"\n            @focus=\"() => handleFocus(indexTab, indexEmoji)\"\n            @keydown=\"event => handleKeyDown(event, indexTab, indexEmoji, emoji)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"getImgSrc(emoji.unicode_character)\"\n              @error=\"handleImageError\"\n            >\n          </button>\n        </div>\n      </div>\n      <div\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <div\n          class=\"d-emoji-picker__tab \"\n        >\n          <button\n            v-for=\"(emoji, index) in filteredEmojis\"\n            :key=\"emoji.shortname\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            :class=\"{\n              'hover-emoji': (index === 0 && hoverFirstEmoji),\n            }\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"hoverEmoji(emoji)\"\n            @mouseleave=\"hoverEmoji(null)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"`${CDN_URL + emoji.unicode_character}.png`\"\n            >\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { emojisGrouped as emojis } from '@/components/emoji_picker/emojis';\nimport { computed, onMounted, onUnmounted, ref, watch, nextTick } from 'vue';\nimport { CDN_URL, EMOJIS_PER_ROW } from '@/components/emoji_picker/emoji_picker_constants';\n\nconst props = defineProps({\n  /**\n   * The filter to apply to the emoji list\n   * @type {String}\n   * @default ''\n   */\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The labels for the tabset\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  selectedTabset: {\n    type: Object,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of recently used emojis\n   * @type {Array}\n   */\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => [],\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when the user hover over an emoji\n   * @event highlighted-emoji\n   * @param {Object} emoji - The emoji data that was hovered\n    */\n  'highlighted-emoji',\n\n  /**\n   * Emitted when the user select an emoji\n   * @event selected-emoji\n   * @param {Object} emoji - The emoji data that was selected\n    */\n  'selected-emoji',\n\n  /**\n   * Emitted when the user scroll into an emoji tab\n   * @event scroll-into-tab\n   * @param {Number} tab-index - The tab that was scrolled into\n    */\n  'scroll-into-tab',\n\n  /**\n   * Emitted when the scrollTo function starts scrolling and stops scrolling\n   * @event is-scrolling\n   * @param {Boolean} is-scrolling - Whether the user is scrolling with the scroll-to\n    */\n  'is-scrolling',\n\n  /**\n   * Emitted when the user reach the end of the emoji list\n   * @event focus-skin-selector\n    */\n  'focus-skin-selector',\n]);\n\n/**\n * The ref for the tab category\n * This is used to display the fixed label\n */\nconst tabCategoryRef = ref(null);\n\n/**\n * The ref for the list\n * This is used to display the tabs\n */\nconst listRef = ref(null);\n\n/**\n * The ref for the tab label observer\n * This is used to update the fixed label\n */\nconst tabLabelObserver = ref(null);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n */\nconst TABS_DATA = ['Recently used', 'People', 'Nature', 'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags'];\n\n/**\n * The list of tab labels\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n */\nconst tabLabels = computed(() => {\n  return props.recentlyUsedEmojis.length\n    ? props.tabsetLabels.map((label) => ({ label, ref: ref(null) }))\n    : props.tabsetLabels.slice(1).map((label) => ({ label, ref: ref(null) }));\n});\n\n/**\n * The label of the fixed tab\n * This is used to display the fixed label\n */\nconst fixedLabel = ref(tabLabels.value[0].label);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n * The difference between this and the tab labels is that this one will set the structure of tabs\n * and the tab labels will set the labels\n */\nconst tabs = computed(() => {\n  return props.recentlyUsedEmojis.length ? TABS_DATA : TABS_DATA.slice(1);\n});\n\n/**\n * The list of current emojis that match the filter\n * This will be updated when the emojiFilter changes\n * This is used to display the search results\n * The difference between this and the current emojis list is that this one will not have the skin tone applied\n */\nconst filteredEmojis = ref([]);\n\n/**\n * This flag is necessary to hover\n */\nconst hoverFirstEmoji = ref(true);\n\n/**\n * The current emojis list we are displaying\n * This will be updated when the skin tone changes\n * The difference between this and the emojis list is that this one will have only the skin tone applied\n */\nconst currentEmojis = computed(() => {\n  return [\n    ...emojis[`People${props.skinTone}`],\n    ...emojis.Nature,\n    ...emojis.Food,\n    ...emojis[`Activity${props.skinTone}`],\n    ...emojis.Travel,\n    ...emojis[`Objects${props.skinTone}`],\n    ...emojis.Symbols,\n    ...emojis.Flags,\n  ];\n});\n\n/**\n * This will trigger the searchByNameAndKeywords function with debounce of 300 milliseconds\n */\nconst debouncedSearch = debounce(() => {\n  searchByNameAndKeywords();\n});\n\n/**\n * Update the current emojis list on skin tone changes\n * Also update the filtered emojis list\n * @listens skinTone\n */\nwatch(currentEmojis, () => {\n  searchByNameAndKeywords();\n}, { immediate: true });\n\n/**\n * Update the recently used emojis list on recently used emojis prop changes\n * @listens recentlyUsedEmojis\n */\nwatch(() => props.recentlyUsedEmojis,\n  () => {\n    emojis['Recently used'] = props.recentlyUsedEmojis;\n  }, { immediate: true });\n\n/**\n * Search for emojis by name and keywords\n * Will update the filtered emojis list on emojiFilter update\n * @listens emojiFilter\n */\nwatch(() => props.emojiFilter, () => {\n  resetScroll();\n  // If the emoji filter is empty, emit null to remove the highlighted emoji\n  // of the previous search\n  if (!props.emojiFilter) { emits('highlighted-emoji', null); }\n  debouncedSearch();\n});\n\nwatch(\n  () => props.selectedTabset,\n  (tab) => {\n    scrollToTab(tab.tabId);\n  },\n  { deep: true },\n);\n\n/**\n * Filters an array of emoji objects based on a search string that matches both the name and keywords.\n * Will update the filtered emojis list\n */\nfunction searchByNameAndKeywords () {\n  const searchStr = props.emojiFilter.toLowerCase();\n  filteredEmojis.value = currentEmojis.value.filter(obj => {\n    const nameIncludesSearchStr = obj.name.toLowerCase().includes(searchStr);\n    const keywordsIncludeSearchStr = obj.keywords.some(keyword => keyword.toLowerCase().includes(searchStr));\n    return nameIncludesSearchStr || keywordsIncludeSearchStr;\n  });\n  nextTick(() => {\n    if (searchStr) {\n      hoverEmoji(filteredEmojis.value[0], true);\n    }\n  });\n}\n\nfunction debounce (fn, delay = 300) {\n  let timeout;\n\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), delay);\n  };\n}\n\nfunction getImgSrc (emoji) {\n  return `${CDN_URL + emoji}.png`;\n}\n\n/**\n * Handle image error - We hide the entire button if the image is not found\n */\nfunction handleImageError (event) {\n  event.target.parentNode.style.display = 'none';\n}\n\n/**\n * Scroll to the selected tab\n */\nfunction scrollToTab (tabIndex, focusFirstEmoji = true) {\n  const tabLabel = tabLabels.value[tabIndex - 1];\n  const tabElement = tabLabel.ref.value[0];\n\n  nextTick(() => {\n    const container = listRef.value;\n    const offsetTop = tabIndex === '1' ? 0 : tabElement.offsetTop - 20;\n\n    /**\n     * This variable is used to check if the user is scrolling inside the emoji picker\n     * This is used to check if the user is scrolling using the scrollTo function\n     * This is useful because this flag will prevent to update the fixed label when the user is scrolling using the scrollTo function\n     */\n    let isScrolling = true;\n\n    let prevScrollTop = container.scrollTop;\n    emits('is-scrolling', true);\n\n    /**\n     * This event listener checks whether the user is scrolling up or down by comparing the current scrollTop to prevScrollTop.\n     * If the scrollToTab function is scrolling from bottom to top and has reached the desired position (scrollTop <= offsetTop),\n     * or if the scrollToTab function is scrolling from top to bottom and has passed the desired position (scrollTop >= offsetTop),\n     * then isScrolling is set to false.\n     */\n    container.addEventListener('scroll', () => {\n      if (isScrolling) {\n        const scrollTop = container.scrollTop;\n        if (\n          (prevScrollTop < scrollTop && scrollTop >= offsetTop) ||\n          (prevScrollTop > scrollTop && scrollTop <= offsetTop)\n        ) {\n          isScrolling = false;\n          emits('is-scrolling', false);\n        }\n        prevScrollTop = scrollTop;\n      }\n    });\n\n    container.scrollTop = offsetTop;\n\n    if (focusFirstEmoji) {\n      focusEmoji((tabIndex - 1), 0);\n    }\n  });\n}\n\nfunction resetScroll () {\n  const container = listRef.value;\n\n  container.scrollTop = 0;\n}\n\n/**\n * This code creates an IntersectionObserver object that monitors the intersection between\n * the root element (tabCategoryRef) and its targets (the child elements of listRef),\n * and updates the value of the fixedLabel variable accordingly.\n */\nfunction setTabLabelObserver () {\n  /**\n   * The code extracts the target element and its index from the IntersectionObserverEntry object,\n   * and checks whether the target intersects with the root and is positioned above or below it.\n   */\n  tabLabelObserver.value = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const { target } = entry;\n      const index = parseInt(target.dataset.index);\n\n      /**\n       * If the target is positioned above the root,\n       * the code updates the value of the fixed label to the label of the previous tab, or the first tab if the current tab is the first one.\n       * If the target is positioned below the root, the code updates the value of the fixed label to the label of the current tab.\n       * If the target stops intersecting with the root and its index is 1 (the second tab),\n       * the code updates the value of the fixed label to the label of the first tab.\n       * NOTES:\n       * This last condition is needed because sometimes it is\n       * not detect the intersection between the root and the target.\n       * We also provide a 50 pixels offset to the root element in the first condition to always get the\n       * first tab if it has fewer emojis, because in some cases if you quickly scroll the observer does not detect it.\n       */\n      if (entry.isIntersecting && target.offsetTop <= tabCategoryRef.value.offsetTop + 50) {\n        fixedLabel.value = tabLabels.value[index - 1]?.label ?? tabLabels.value[0]?.label;\n        emits('scroll-into-tab', index - 1);\n      } else if (entry.boundingClientRect.bottom <= tabCategoryRef.value?.getBoundingClientRect().bottom) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[index]?.label;\n      } else if (index === 1) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[0]?.label;\n      }\n    });\n  });\n\n  /**\n   * The tabLabelObserver is set to observe the root element and all its children elements with\n   * the IntersectionObserver object, and sets their data-index attribute to their index.\n   */\n  tabLabelObserver.value.observe(tabCategoryRef.value);\n\n  Array.from(listRef.value.children).forEach((child, index) => {\n    tabLabelObserver.value.observe(child);\n    child.dataset.index = index;\n  });\n}\n\nfunction hoverEmoji (emoji, isFirst = false) {\n  hoverFirstEmoji.value = isFirst;\n  emits('highlighted-emoji', emoji);\n}\n\nconst emojiRefs = ref([]);\nfunction setEmojiRef (el, indexTab, indexEmoji) {\n  if (!emojiRefs.value[indexTab]) {\n    emojiRefs.value[indexTab] = [];\n  }\n  emojiRefs.value[indexTab][indexEmoji] = el;\n}\n\nfunction focusEmoji (indexTab, indexEmoji) {\n  const emojiRef = emojiRefs.value?.[indexTab]?.[indexEmoji];\n\n  if (emojiRef) {\n    emojiRef.focus();\n    return true;\n  }\n\n  return false;\n}\n\nconst handleFocus = (indexTab, indexEmoji) => {\n  // console.log(indexTab, indexEmoji);\n\n  // console.log('Element focused');\n};\n\nconst handleKeyDown = (event, indexTab, indexEmoji, emoji) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowUp') {\n    const position = indexEmoji % EMOJIS_PER_ROW;\n\n    if (indexTab === 0) {\n      // we are on the first emoji tab, then we should jump to the last row of the last emoji tab\n      const numberOfMissingEmojis = EMOJIS_PER_ROW - (emojiRefs.value[emojiRefs.value.length - 1].length % EMOJIS_PER_ROW);\n\n      const emojiToJump = emojiRefs.value[emojiRefs.value.length - 1].length + numberOfMissingEmojis - (EMOJIS_PER_ROW - position);\n\n      if (!focusEmoji(emojiRefs.value.length - 1, emojiToJump)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n      return;\n    }\n\n    // if we are not on the first tab, we should jump to the previous row of the current tab\n    if (!focusEmoji(indexTab, indexEmoji - EMOJIS_PER_ROW)) {\n      // if there is no previous row, we should jump to emoji in the sampe position of the previous tab\n      const previousTab = indexTab - 1 < 0 ? 0 : indexTab - 1;\n      const emojisInPreviousTab = emojiRefs.value[previousTab].length;\n      const lastEmojiPosition = emojisInPreviousTab - (emojisInPreviousTab % EMOJIS_PER_ROW) + position;\n\n      if (!focusEmoji(previousTab, lastEmojiPosition)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowDown') {\n    if (!focusEmoji(indexTab, indexEmoji + EMOJIS_PER_ROW)) {\n      // if cannot go down\n\n      // Calculate position from cell 0 to cell 8\n      const position = indexEmoji % EMOJIS_PER_ROW;\n\n      // check if it exists a next row in the current tab\n      if (emojiRefs.value?.[indexTab]?.[indexEmoji + (EMOJIS_PER_ROW - position)]) {\n        // if it exists, we should focus the last emoji of the next row in the current tab\n        focusEmoji(indexTab, emojiRefs.value[indexTab].length - 1);\n        // if we are at the end of the list it will do nothing\n      } else {\n        // We don't have next row, we are in the last of the tab, then jump\n        // to the next tab but in the equal emoji position in row 0.\n\n        if (!focusEmoji(indexTab + 1, position)) {\n          // We are on the bottom!, should jump to the same position emoji in the first row of the first tabset\n          // if it doesn't has, jump to the last\n          if (!focusEmoji(0, position)) {\n            focusEmoji(0, emojiRefs.value[0].length - 1);\n          }\n        }\n      }\n    }\n  }\n\n  if (event.key === 'ArrowLeft') {\n    if (!focusEmoji(indexTab, indexEmoji - 1)) {\n      // Jump to the last emoji of the previous tab\n      // handle end of tab\n      if (emojiRefs.value[indexTab - 1]) {\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      } else {\n        // jump to the last emoji of the last tab\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowRight') {\n    if (!focusEmoji(indexTab, indexEmoji + 1)) {\n      // Jump to the next tab\n      // handle end of tab\n      if (!focusEmoji(indexTab + 1, 0)) {\n      // when reach the end of the list, jump to the first emoji of the first tabset\n        focusEmoji(0, 0);\n      }\n    }\n  }\n\n  if (event.key === 'Tab') {\n    if (focusEmoji(indexTab + 1, 0)) {\n      scrollToTab((indexTab + 1) + 1, false);\n    } else {\n      // We are on the last emoji tabset, jump to the skin selector\n      emits('focus-skin-selector');\n    }\n  }\n\n  if (event.key === 'Enter') {\n    emits('selected-emoji', emoji);\n  }\n};\n\nonMounted(() => {\n  setTabLabelObserver();\n});\n\nonUnmounted(() => {\n  tabLabelObserver.value.disconnect();\n});\n</script>\n\n<style lang=\"less\" scoped>\n.d-emoji-picker{\n\n  &__selector{\n    min-height: 297px;\n\n    p{\n      margin-bottom: 4px;\n      font-size: 12px;\n      font-weight: 700;\n      letter-spacing: -0.01em;\n    }\n  }\n\n  &__category {\n    background: rgba(255, 255, 255, 0.9);\n    position: sticky;\n    top: 0;\n    padding-top: 20px;\n    width: 100%;\n  }\n\n  &__list{\n    height: 100%;\n    max-height: 297px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    position: relative;\n    top: -20px;\n\n    div:not(:first-child){\n      p{\n        margin-top: 22px;\n      }\n    }\n  }\n\n  &__search-label{\n    margin-top: 20px;\n  }\n\n  &__tab{\n    width: calc(100% + 15px);\n    max-width: 340px;\n    gap: 2px;\n    display: flex;\n    flex-wrap: wrap;\n    // We use this margin left to align the emoji list with the tabset label\n    margin-left: -6px;\n\n    button{\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 50%;\n      width: 36px;\n      height: 36px;\n\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      padding: 0;\n      outline: none;\n\n      &:hover, &:active{\n        background: rgba(0, 0, 0, 0.1);\n      }\n\n      &.hover-emoji{\n        background: rgba(0, 0, 0, 0.1);\n      }\n\n      &:focus{\n        box-shadow: var(--bs-focus-ring);\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div>\n    <div\n      v-show=\"isOpen\"\n      class=\"d-emoji-picker__skin-list\"\n    >\n      <button\n        v-for=\"(skin, index) in skinList\"\n        :ref=\"el => { if (el) setSkinsRef(el) }\"\n        :key=\"skin.name\"\n        :class=\"{\n          'selected': skinSelected.skinCode === skin.skinCode,\n        }\"\n        @keydown=\"event => handleKeyDown(event, skin, index)\"\n        @click=\"selectSkin(skin)\"\n      >\n        <img\n          class=\"d-icon d-icon--size-500\"\n          :alt=\"skin.name\"\n          :aria-label=\"skin.name\"\n          :title=\"skin.name\"\n          :src=\"`${CDN_URL + skin.unicode_output}.png`\"\n        >\n      </button>\n    </div>\n    <div\n      v-show=\"!isOpen\"\n      class=\"d-emoji-picker__skin-selected\"\n    >\n      <dt-tooltip placement=\"top-end\">\n        {{ skinSelectorButtonTooltipLabel }}\n        <template #anchor>\n          <button\n            ref=\"skinSelectorRef\"\n            @click=\"toggleSkinList\"\n            @keydown=\"event => handleKeyDown(event)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"skinSelected.name\"\n              :aria-label=\"skinSelected.name\"\n              :title=\"skinSelected.name\"\n              :src=\"`${CDN_URL + skinSelected.unicode_output}.png`\"\n            >\n          </button>\n        </template>\n      </dt-tooltip>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { nextTick, ref, watchEffect } from 'vue';\nimport { CDN_URL } from '@/components/emoji_picker/emoji_picker_constants';\nimport DtTooltip from '@/components/tooltip/tooltip.vue';\n\nconst props = defineProps({\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  isHovering: {\n    type: Boolean,\n    default: false,\n  },\n\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * The skin tone that was selected\n   * @event skin-tone\n   * @type {Number}\n   */\n  'skin-tone',\n  'focus-tabset',\n]);\n\nconst skinList = [\n  {\n    name: ':wave_tone1:',\n    unicode_output: '1f44b-1f3fb',\n    skinTone: 'Light',\n    skinCode: '_tone1',\n  },\n  {\n    name: ':wave_tone2:',\n    unicode_output: '1f44b-1f3fc',\n    skinTone: 'MediumLight',\n    skinCode: '_tone2',\n  },\n  {\n    name: ':wave_tone3:',\n    unicode_output: '1f44b-1f3fd',\n    skinTone: 'Medium',\n    skinCode: '_tone3',\n  },\n  {\n    name: ':wave_tone4:',\n    unicode_output: '1f44b-1f3fe',\n    skinTone: 'MediumDark',\n    skinCode: '_tone4',\n  },\n  {\n    name: ':wave_tone5:',\n    unicode_output: '1f44b-1f3ff',\n    skinTone: 'Dark',\n    skinCode: '_tone5',\n  },\n  {\n    name: ':wave:',\n    unicode_output: '1f44b',\n    skinTone: 'Default',\n    skinCode: '',\n  },\n];\n\nconst skinSelected = ref(skinList.find((skin) => skin.skinTone === props.skinTone));\n\nconst isOpen = ref(false);\n\nconst skinSelectorRef = ref(null);\n\nconst skinsRef = ref([]);\n\n/**\n * It will close the skin selector if the user is hovering over the emoji list\n */\nwatchEffect(\n  () => props.isHovering && (isOpen.value = false),\n);\n\nfunction setSkinsRef (ref) {\n  skinsRef.value.push(ref);\n}\nfunction focusSkinSelector () {\n  skinSelectorRef.value.focus();\n}\n\nfunction selectSkin (skin) {\n  skinSelected.value = skin;\n  isOpen.value = false;\n  emits('skin-tone', skin.skinTone);\n  nextTick(() => focusSkinSelector());\n}\n\nconst handleKeyDown = (event, skin, index) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowLeft') {\n    if (index === 0) skinsRef.value[skinsRef.value.length - 1]?.focus();\n    skinsRef.value[index - 1]?.focus();\n  }\n\n  if (event.key === 'ArrowRight') {\n    skinsRef.value[index + 1]?.focus();\n  }\n\n  if (event.key === 'Enter') {\n    if (skin) { selectSkin(skin); } else {\n      toggleSkinList();\n    }\n  }\n\n  if (event.key === 'Tab') {\n    emits('focus-tabset');\n  }\n};\n\nfunction toggleSkinList () {\n  isOpen.value = !isOpen.value;\n  nextTick(() => skinsRef.value[0].focus());\n}\n\ndefineExpose({\n  focusSkinSelector,\n});\n</script>\n\n<style lang=\"less\" scoped>\n.d-emoji-picker{\n  &__skin-list{\n    display: inline-flex;\n    border-radius: 40px;\n    background: rgba(0, 0, 0, 0.05);\n    flex-direction: row;\n    align-items: flex-start;\n    padding: 4px;\n    gap: 4px;\n\n    button{\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      padding: 0;\n      outline: none;\n      border-radius: 28px;\n      width: 34px;\n      height: 34px;\n\n      &:hover{\n        background: rgba(0, 0, 0, 0.1);\n        border-radius: 28px;\n      }\n\n      &.selected{\n        border: 1px solid rgba(0, 0, 0, 0.25);\n        border-radius: 28px;\n      }\n    }\n  }\n\n  &__skin-selected{\n    button{\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      outline: none;\n      padding: 7px;\n      display: inline-block;\n      background: rgba(0, 0, 0, 0.1);\n      border-radius: 28px;\n      width: 42px;\n      height: 42px;\n\n      &:hover{\n        background: #D2D2D2;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div\n    class=\"d-emoji-picker\"\n  >\n    <div class=\"d-emoji-picker--header\">\n      <emoji-tabset\n        ref=\"tabsetRef\"\n        :emoji-filter=\"searchQuery\"\n        :show-recently-used-tab=\"showRecentlyUsedTab\"\n        :scroll-into-tab=\"scrollIntoTab\"\n        :tabset-labels=\"tabSetLabels\"\n        :is-scrolling=\"isScrolling\"\n        @focus-search-input=\"$refs.searchInputRef.focusSearchInput()\"\n        @selected-tabset=\"scrollToSelectedTabset\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--body\">\n      <emoji-search\n        ref=\"searchInputRef\"\n        v-model=\"searchQuery\"\n        :search-placeholder-label=\"searchPlaceholderLabel\"\n        @keydown.enter=\"emits('selected-emoji', highlightedEmoji)\"\n      />\n      <emoji-selector\n        :emoji-filter=\"searchQuery\"\n        :skin-tone=\"skinTone\"\n        :tabset-labels=\"tabSetLabels\"\n        :search-results-label=\"searchResultsLabel\"\n        :search-no-results-label=\"searchNoResultsLabel\"\n        :recently-used-emojis=\"recentlyUsedEmojis\"\n        :selected-tabset=\"selectedTabset\"\n        @scroll-into-tab=\"updateScrollIntoTab\"\n        @is-scrolling=\"updateIsScrolling\"\n        @highlighted-emoji=\"updateHighlightedEmoji\"\n        @selected-emoji=\"emits('selected-emoji', $event)\"\n        @focus-skin-selector=\"$refs.skinSelectorRef.focusSkinSelector()\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--footer\">\n      <emoji-description :emoji=\"highlightedEmoji\" />\n      <emoji-skin-selector\n        ref=\"skinSelectorRef\"\n        :is-hovering=\"!!highlightedEmoji\"\n        :skin-selector-button-tooltip-label=\"skinSelectorButtonTooltipLabel\"\n        :skin-tone=\"skinTone\"\n        @skin-tone=\"emits('skin-tone', $event)\"\n        @focus-tabset=\"$refs.tabsetRef.focusTabset()\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport EmojiSearch from './modules/emoji_search.vue';\nimport EmojiTabset from './modules/emoji_tabset.vue';\nimport EmojiSelector from './modules/emoji_selector.vue';\nimport EmojiSkinSelector from './modules/emoji_skin_selector.vue';\nimport EmojiDescription from './modules/emoji_description.vue';\nimport { computed, ref } from 'vue';\n\nconst props = defineProps({\n  /**\n   * The array with recently used  emoji object\n   * This list is necessary to fill the recently used tab\n   * @type {Array}\n   * @default []\n   * @example\n   * <dt-emoji-picker :recentlyUsedEmojis=\"[emojiObject, emojiObject]\" />\n   */\n  // TODO try to simplify this to achieve an array of unicode characters and not an entire emoji data object\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => ([]),\n  },\n\n  /**\n   * The placeholder text for the search input\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchPlaceholderLabel=\"'Search...'\" />\n   */\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchResultsLabel=\"'Search results'\" />\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search no results\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchNoResultsLabel=\"'No results'\" />\n   */\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of tabsets to show, it is necessary to be updated with the correct language\n   * It must respect the provided order.\n   * @type {Array}\n   * @required\n   * @example\n   * <dt-emoji-picker\n   *  :tabSetLabels=\"['Most recently used', 'Smileys and people', 'Nature',\n   *    'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags']\" />\n   */\n  tabSetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  /**\n   * The skin tone to show the emojis\n   * This prop gives the possibility to use the skin tone selected by the user previously\n   * @type {String}\n   * @default 'Default'\n   * @values 'Default', 'Light', 'MediumLight', 'Medium', 'MediumDark', 'Dark'\n   * @example\n   * <dt-emoji-picker :skinTone=\"'Default'\" />\n   */\n  skinTone: {\n    type: String,\n    default: 'Default',\n  },\n\n  /**\n   * Tooltip shown when skin selector button is hovered.\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :skin-selector-button-tooltip-label=\"'Change default skin tone'\" />\n   */\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits(\n  [\n    /**\n     * It will emit the selected emoji\n     * @event selected-emoji\n     * @param {Object} emoji - The selected emoji from the emoji selector\n     */\n    'selected-emoji',\n\n    /**\n     * It will emit the selected skin tone\n     * @event skin-tone\n     * @param {String} skin - The selected skin tone from the skin selector\n     */\n    'skin-tone',\n  ],\n);\n\nconst searchQuery = ref('');\nconst highlightedEmoji = ref(null);\nconst selectedTabset = ref({});\n\nconst scrollIntoTab = ref(0);\nconst isScrolling = ref(false);\n\nconst showRecentlyUsedTab = computed(() => props.recentlyUsedEmojis.length > 0);\n\n/**\n * Handle the selected tabset event\n * We're creating a new object with the same value as selectedTabset and assigning it back to selectedTabset.\n * Vue will see this as a new object and trigger the watcher in the child component.\n * Using this method, we are able to trigger the watcher in the child component even if the value being passed is the\n * same as the previous value.\n * @event selectedTabset\n * @param tabName {String} - The name of the tab that was selected\n */\nfunction scrollToSelectedTabset (tabId) {\n  searchQuery.value = '';\n  selectedTabset.value = tabId;\n  selectedTabset.value = { ...selectedTabset.value, tabId };\n}\n\nfunction updateScrollIntoTab (value) {\n  scrollIntoTab.value = value;\n}\n\nfunction updateIsScrolling (value) {\n  isScrolling.value = value;\n}\nfunction updateHighlightedEmoji (emoji) {\n  highlightedEmoji.value = emoji;\n}\n</script>\n\n<style lang=\"less\">\n.d-emoji-picker{\n  // fixed with to achieve accessibility in keyboard\n  // with this width we have 9 emoji per row\n  width: 372px;\n  height: 100%;\n  display: inline-flex;\n  flex-direction: column;\n  border-radius: 4px;\n\n  &--header{\n    padding: var(--su4) var(--su4) 0 var(--su8);\n    position: relative;\n    &::after{\n      content: '';\n      position: absolute;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      height: 1px;\n      background-color: var(--bgc-moderate) !important;\n    }\n  }\n\n  &__alignment{\n    width: auto;\n    max-width: 340px;\n    margin: 0 16px;\n  }\n\n  &--footer{\n    position: relative;\n    height: 58px;\n    top: -20px;\n    background: #F9F9F9;\n    border-top: 1px solid var(--bc-subtle);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 16px;\n  }\n}\n</style>\n","<template>\n  <dt-emoji-picker\n    :skin-tone=\"skinTone\"\n    :skin-selector-button-tooltip-label=\"$attrs.skinSelectorButtonTooltipLabel\"\n    :tab-set-labels=\"$attrs.tabSetLabels\"\n    :recently-used-emojis=\"$attrs.recentlyUsedEmojis\"\n    :search-results-label=\"$attrs.searchResultsLabel\"\n    :search-no-results-label=\"$attrs.searchNoResultsLabel\"\n    :search-placeholder-label=\"$attrs.searchPlaceholderLabel\"\n    @skin-tone=\"skinTone = $event\"\n    @selected-emoji=\"$attrs.selectedEmoji\"\n  />\n</template>\n\n<script setup>\nimport DtEmojiPicker from './emoji_picker.vue';\nimport { ref } from 'vue';\n\nconst skinTone = ref('Light');\n</script>\n"],"names":["searchInput","ref","focusSearchInput","onMounted","expose","TABS_DATA","tabs","computed","props","tab","index","isSearching","selectedTab","isScrolling","toRefs","tabsetRef","watch","selectTabset","id","emits","setTabsetRef","focusTabset","handleKeyDown","event","tabId","CDN_URL","EMOJIS_PER_ROW","tabCategoryRef","listRef","tabLabelObserver","tabLabels","label","fixedLabel","filteredEmojis","hoverFirstEmoji","currentEmojis","emojis","debouncedSearch","debounce","searchByNameAndKeywords","resetScroll","scrollToTab","searchStr","obj","nameIncludesSearchStr","keywordsIncludeSearchStr","keyword","nextTick","hoverEmoji","fn","delay","timeout","args","getImgSrc","emoji","handleImageError","tabIndex","focusFirstEmoji","tabElement","container","offsetTop","prevScrollTop","scrollTop","focusEmoji","setTabLabelObserver","entries","entry","target","_a","_b","_c","_d","_e","child","isFirst","emojiRefs","setEmojiRef","el","indexTab","indexEmoji","emojiRef","handleFocus","position","numberOfMissingEmojis","emojiToJump","previousTab","emojisInPreviousTab","lastEmojiPosition","onUnmounted","skinList","skinSelected","skin","isOpen","skinSelectorRef","skinsRef","watchEffect","setSkinsRef","focusSkinSelector","selectSkin","toggleSkinList","searchQuery","highlightedEmoji","selectedTabset","scrollIntoTab","showRecentlyUsedTab","scrollToSelectedTabset","updateScrollIntoTab","value","updateIsScrolling","updateHighlightedEmoji","skinTone"],"mappings":"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"}