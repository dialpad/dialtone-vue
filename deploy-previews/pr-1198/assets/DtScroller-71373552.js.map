{"version":3,"file":"DtScroller-71373552.js","sources":["../../components/scroller/modules/core_scroller.vue","../../components/scroller/modules/scroller_item.vue","../../components/scroller/modules/dynamic_scroller.vue","../../components/scroller/DtScroller.vue"],"sourcesContent":["<template>\n  <div\n    ref=\"scroller\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: `${totalSize}px` }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view in pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: undefined,\n          height: undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key,\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n    </component>\n  </div>\n</template>\n\n<!--\nThis is a code from external library (https://github.com/Akryum/vue-virtual-scroller/blob/master/packages/vue-virtual-scroller/src/components/RecycleScroller.vue)\nWe have modified it for our own specific use.\n-->\n<script setup>\nimport { computed, watch, markRaw, shallowReactive, onMounted, nextTick, reactive, ref } from 'vue';\n\nconst props = defineProps({\n  /**\n     * List of items you want to display in the scroller.\n     */\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  /**\n     *\n     * Field used to identify items and optimize managing rendered views\n     */\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  /**\n     * Direction of the scroller. Can be either `vertical` or `horizontal`.\n     */\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  /**\n     * Size of the items in the list.\n     * If it is set to null (the default value), it will use variable size mode.\n     */\n  itemSize: {\n    type: Number,\n    default: null,\n  },\n\n  /**\n     * Minimum size used if the height (or width in horizontal mode) of an item is unknown.\n     */\n  minItemSize: {\n    type: [Number, String],\n    default: null,\n  },\n\n  /**\n     * Field used to get the item's size in variable size mode.\n     */\n  sizeField: {\n    type: String,\n    default: 'size',\n  },\n\n  /**\n     * Amount of pixel to add to edges of the scrolling visible area to start rendering items further away.\n     */\n  buffer: {\n    type: Number,\n    default: 200,\n  },\n\n  /**\n     * If true, the hover state will be skipped.\n     * This can be useful if you want to use the hover state for other purposes.\n     */\n  skipHover: {\n    type: Boolean,\n    default: false,\n  },\n\n  /**\n     * The element to render as the list's wrapper.\n     */\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  /**\n     * The element to render as the list item.\n     */\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n\n  /**\n     * The custom classes added to the item list wrapper.\n     */\n  listClass: {\n    type: [String, Object, Array],\n    default: '',\n  },\n\n  /**\n     * The custom classes added to each item.\n     */\n  itemClass: {\n    type: [String, Object, Array],\n    default: '',\n  },\n});\n\nconst emit = defineEmits(['user-position']);\n\nconst views = reactive(new Map());\n// const reactiveItems = reactive(props.items);\nconst unusedViews = reactive(new Map());\nconst updateTimeout = null;\nconst pool = ref([]);\nconst hoverKey = ref(null);\nconst ready = ref(false);\nconst scroller = ref(null);\nconst userPosition = ref('top');\n\nlet startIndex = 0;\nlet endIndex = 0;\nlet scrollDirty = false;\nlet lastUpdateScrollPosition = 0;\nlet sortTimer = null;\nlet computedMinItemSize = null;\nlet totalSize = 0;\nlet uid = 0;\n\nconst sizes = computed(() => {\n  if (props.itemSize === null) {\n    const sizes = {\n      '-1': { accumulator: 0 },\n    };\n    const items = props.items;\n    const field = props.sizeField;\n    const minItemSize = props.minItemSize;\n    let computedMinSize = 10000;\n    let accumulator = 0;\n    let current;\n    for (let i = 0, l = items.length; i < l; i++) {\n      current = items[i][field] || minItemSize;\n      if (current < computedMinSize) {\n        computedMinSize = current;\n      }\n      accumulator += current;\n      sizes[i] = { accumulator, size: current };\n    }\n\n    computedMinItemSize = computedMinSize;\n    return sizes;\n  }\n  return [];\n});\n\nconst simpleArray = computed(() => {\n  return props.items.length && typeof props.items[0] !== 'object';\n});\n\nconst itemIndexByKey = computed(() => {\n  const result = {};\n  for (let i = 0, l = props.items.length; i < l; i++) {\n    result[props.items[i][props.keyField]] = i;\n  }\n  return result;\n});\n\n// watch(reactiveItems, () => {\n//   // if add to the top\n//   // _updateVisibleItems(true);\n//   // if autoscrolling  if add to the bottom\n//   // _updateVisibleItems(false, true);\n// });\n\nwatch(sizes, () => {\n  _updateVisibleItems(false);\n}, { deep: true });\n\nonMounted(() => {\n  nextTick(() => {\n    // In SSR mode, render the real number of visible items\n    _updateVisibleItems(true);\n    ready.value = true;\n  });\n});\n\nconst _addView = (pool, index, item, key, type) => {\n  const nr = markRaw({\n    id: uid++,\n    index,\n    used: true,\n    key,\n    type,\n  });\n  const view = shallowReactive({\n    item,\n    position: 0,\n    nr,\n  });\n  pool.value.push(view);\n  return view;\n};\n\nconst _unuseView = (view, fake = false) => {\n  const _unusedViews = unusedViews;\n  const type = view.nr.type;\n  let unusedPool = _unusedViews.get(type);\n  if (!unusedPool) {\n    unusedPool = [];\n    _unusedViews.set(type, unusedPool);\n  }\n  unusedPool.push(view);\n  if (!fake) {\n    view.nr.used = false;\n    view.position = -9999;\n  }\n};\n\nconst _getScroll = () => {\n  const isVertical = props.direction === 'vertical';\n  let scrollState;\n\n  if (isVertical) {\n    scrollState = {\n      start: scroller.value.scrollTop,\n      end: scroller.value.scrollTop + scroller.value.clientHeight,\n    };\n  } else {\n    scrollState = {\n      start: scroller.value.scrollLeft,\n      end: scroller.value.scrollLeft + scroller.value.clientWidth,\n    };\n  }\n\n  return scrollState;\n};\n\nconst _itemsLimitError = () => {\n  setTimeout(() => {\n    // eslint-disable-next-line max-len\n    console.error('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', scroller);\n    // eslint-disable-next-line max-len\n    console.error('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.');\n  });\n  throw new Error('Rendered items limit reached');\n};\n\nconst _sortViews = () => {\n  pool.value.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index);\n};\n\nconst _updateVisibleItems = (checkItem, checkPositionDiff = false) => {\n  const itemSize = props.itemSize;\n  const minItemSize = computedMinItemSize;\n  const keyField = simpleArray.value ? null : props.keyField;\n  const items = props.items;\n  const count = items.length;\n  const _sizes = sizes.value;\n  const _views = views;\n  const _unusedViews = unusedViews;\n  const _pool = pool;\n  const _itemIndexByKey = itemIndexByKey;\n  let _startIndex, _endIndex;\n  let _totalSize;\n  let visibleStartIndex, visibleEndIndex;\n\n  if (!count) {\n    _startIndex = _endIndex = visibleStartIndex = visibleEndIndex = _totalSize = 0;\n  } else {\n    const scroll = _getScroll();\n\n    // Skip update if use hasn't scrolled enough\n    if (checkPositionDiff) {\n      let positionDiff = scroll.start - lastUpdateScrollPosition.value;\n      if (positionDiff < 0) positionDiff = -positionDiff;\n      if ((itemSize === null && positionDiff < minItemSize.value) || positionDiff < itemSize) {\n        return {\n          continuous: true,\n        };\n      }\n    }\n    lastUpdateScrollPosition = scroll.start;\n\n    const _buffer = props.buffer;\n    scroll.start -= _buffer;\n    scroll.end += _buffer;\n\n    // Variable size mode\n    if (itemSize === null) {\n      let h;\n      let a = 0;\n      let b = count - 1;\n      let i = ~~(count / 2);\n      let oldI;\n\n      // Searching for _startIndex\n      do {\n        oldI = i;\n        h = _sizes[i]?.accumulator;\n        if (h < scroll.start) {\n          a = i;\n        } else if (i < count - 1 && _sizes[i + 1]?.accumulator > scroll.start) {\n          b = i;\n        }\n        i = ~~((a + b) / 2);\n      } while (i !== oldI);\n      i < 0 && (i = 0);\n      _startIndex = i;\n\n      // For container style\n      _totalSize = _sizes[count - 1]?.accumulator;\n\n      // Searching for _endIndex\n      for (\n        _endIndex = i;\n        _endIndex < count && _sizes[_endIndex]?.accumulator < scroll.end;\n        _endIndex++\n      );\n\n      if (_endIndex === -1) {\n        _endIndex = items.length - 1;\n      } else {\n        _endIndex++;\n        // Bounds\n        _endIndex > count && (_endIndex = count);\n      }\n\n      // search visible _startIndex\n      for (\n        visibleStartIndex = startIndex;\n        visibleStartIndex < count && (_sizes[visibleStartIndex]?.accumulator) < scroll.start;\n        visibleStartIndex++\n      );\n\n      // search visible endIndex\n      for (\n        visibleEndIndex = visibleStartIndex;\n        visibleEndIndex < count && (_sizes[visibleEndIndex]?.accumulator) < scroll.end;\n        visibleEndIndex++\n      );\n    } else {\n      // Fixed size mode\n      _startIndex = ~~(scroll.start / itemSize);\n      const remainer = _startIndex % 1;\n      _startIndex -= remainer;\n      _endIndex = Math.ceil(scroll.end / itemSize);\n      visibleStartIndex = Math.max(0, Math.floor((scroll.start) / itemSize));\n      visibleEndIndex = Math.floor((scroll.end) / itemSize);\n\n      // Bounds\n      _startIndex < 0 && (_startIndex = 0);\n      _endIndex > count && (_endIndex = count);\n      visibleStartIndex < 0 && (visibleStartIndex = 0);\n      visibleEndIndex > count && (visibleEndIndex = count);\n\n      _totalSize = Math.ceil(count / 1) * itemSize;\n    }\n  }\n\n  // items limit 1000\n  if (_endIndex - _startIndex > 1000) {\n    _itemsLimitError();\n  }\n\n  totalSize = _totalSize;\n\n  let view;\n\n  const continuous = _startIndex <= endIndex && _endIndex >= _startIndex;\n\n  // Unuse views that are no longer visible\n  if (continuous) {\n    for (let i = 0, l = _pool.value.length; i < l; i++) {\n      view = _pool.value[i];\n      if (view?.nr.used) {\n        // Update view item index\n        if (checkItem) {\n          view.nr.index = _itemIndexByKey[view.item[keyField]];\n        }\n\n        // Check if index is still in visible range\n        if (\n          view.nr.index == null ||\n          view.nr.index < _startIndex ||\n          view.nr.index >= _endIndex\n        ) {\n          _unuseView(view);\n        }\n      }\n    }\n  }\n\n  const unusedIndex = continuous ? null : new Map();\n\n  let item, type;\n  let v;\n  for (let i = _startIndex; i < _endIndex; i++) {\n    item = items[i];\n    const key = keyField ? item?.[keyField] : item;\n\n    if (key == null) {\n      throw new Error(`Key is ${key} on item (keyField is '${keyField}')`);\n    }\n    view = _views.get(key);\n\n    if (!itemSize && !_sizes[i]?.size) {\n      if (view) _unuseView(view);\n      continue;\n    }\n\n    type = item.type;\n\n    let unusedPool = _unusedViews.get(type);\n    // let newlyUsedView = false;\n\n    // No view assigned to item\n    if (!view) {\n      if (continuous) {\n        // Reuse existing view\n        if (unusedPool && unusedPool.length) {\n          view = unusedPool.pop();\n        } else {\n          view = _addView(_pool, i, item, key, type);\n        }\n      } else {\n        // Use existing view\n        // We don't care if they are already used\n        // because we are not in continous scrolling\n        v = unusedIndex.get(type) || 0;\n\n        if (!unusedPool || v >= unusedPool.length) {\n          view = _addView(_pool, i, item, key, type);\n          _unuseView(view, true);\n          unusedPool = _unusedViews.get(type);\n        }\n\n        view = unusedPool[v];\n        unusedIndex.set(type, v + 1);\n      }\n\n      // Assign view to item\n      _views.delete(view.nr.key);\n      view.nr.used = true;\n      view.nr.index = i;\n      view.nr.key = key;\n      view.nr.type = type;\n      _views.set(key, view);\n\n      // newlyUsedView = true;\n    } else {\n      // View already assigned to item\n      if (!view.nr.used) {\n        view.nr.used = true;\n        // newlyUsedView = true;\n        if (unusedPool) {\n          const index = unusedPool.indexOf(view);\n          if (index !== -1) unusedPool.splice(index, 1);\n        }\n      }\n    }\n\n    // Always set item in case it's a new object with the same key\n    view.item = item;\n\n    // if (newlyUsedView) {\n    //   if (items.length === 0) return;\n    //   if (i === items.length - 1) emit('scroll-end');\n    //   if (i === 0) emit('scroll-start');\n    // }\n\n    // Update position\n    if (itemSize === null) {\n      view.position = _sizes[i - 1]?.accumulator;\n      view.offset = 0;\n    } else {\n      view.position = Math.floor(i) * itemSize;\n      view.offset = (i % 1) * itemSize;\n    }\n  }\n\n  startIndex = _startIndex;\n  endIndex = _endIndex;\n\n  // After the user has finished scrolling\n  // Sort views so text selection is correct\n  clearTimeout(sortTimer);\n  sortTimer = setTimeout(_sortViews, 300);\n\n  return {\n    continuous,\n  };\n};\n\nconst _scrollToPosition = (position) => {\n  const direction = props.direction === 'vertical'\n    ? { scroll: 'scrollTop', start: 'top' }\n    : { scroll: 'scrollLeft', start: 'left' };\n\n  const viewport = scroller.value;\n  const scrollDirection = direction.scroll;\n\n  viewport[scrollDirection] = position;\n};\n\nconst scrollToItem = (index) => {\n  let scroll;\n  if (props.itemSize === null) {\n    scroll = index > 0 ? sizes.value[index - 1]?.accumulator : 0;\n  } else {\n    scroll = Math.floor(index) * props.itemSize;\n  }\n  _scrollToPosition(scroll);\n};\n\nconst handleScroll = () => {\n  const container = scroller.value;\n\n  if (userPosition.value !== 'middle') {\n    userPosition.value = 'middle';\n    emit('user-position', 'middle');\n  }\n\n  // Check if the scroll is at the top of the container\n  if (container.scrollTop === 0) {\n    userPosition.value = 'top';\n    emit('user-position', 'top');\n  }\n\n  // Check if the scroll is at the bottom of the container\n  if (container.scrollTop + container.clientHeight === container.scrollHeight) {\n    userPosition.value = 'bottom';\n    emit('user-position', 'bottom');\n  }\n\n  if (!scrollDirty) {\n    scrollDirty = true;\n    if (updateTimeout) return;\n\n    const requestUpdate = () => requestAnimationFrame(() => {\n      scrollDirty = false;\n      _updateVisibleItems(false, true);\n    });\n\n    requestUpdate();\n  }\n};\n\ndefineExpose({\n  scrollToItem,\n  _updateVisibleItems,\n});\n</script>\n\n<style>\n.vue-recycle-scroller{\n    position:relative\n}\n.vue-recycle-scroller.direction-vertical:not(.page-mode){\n    overflow-y:auto\n}\n.vue-recycle-scroller.direction-horizontal:not(.page-mode){\n    overflow-x:auto\n}\n.vue-recycle-scroller.direction-horizontal{\n    display:flex\n}\n.vue-recycle-scroller__slot{\n    flex:auto 0 0\n}\n.vue-recycle-scroller__item-wrapper{\n    flex:1;\n    box-sizing:border-box;\n    overflow:hidden;\n    position:relative\n}\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view{\n    position:absolute;\n    top:0;\n    left:0;\n    will-change:transform\n}\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper{\n    width:100%\n}\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper{\n    height:100%\n}\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view{\n    width:100%\n}\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view{\n    height:100%\n}\n </style>\n","<!--\nThis is a code from external library (https://github.com/Akryum/vue-virtual-scroller/blob/master/packages/vue-virtual-scroller/src/components/DynamicScrollerItem.vue)\nWe have modified it for our own specific use.\n-->\n<script>\nimport { h } from 'vue';\n\nexport default {\n  name: 'DtScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index;\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField];\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`);\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0;\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active;\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id;\n      if (!this.size) {\n        this.onDataUpdate();\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue];\n        const size = this.vscrollData.sizes[value];\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize);\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++;\n            this.vscrollParent.$_undefinedMap[this.id] = true;\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--;\n            this.vscrollParent.$_undefinedMap[this.id] = false;\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize();\n        } else {\n          this.unobserveSize();\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize();\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return;\n\n    this.$_forceNextVScrollUpdate = null;\n    this.updateWatchData();\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate);\n      }\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize();\n      this.observeSize();\n    }\n  },\n\n  beforeUnmount () {\n    this.unobserveSize();\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id;\n          this.$_forceNextVScrollUpdate = null;\n          this.$_pendingVScrollUpdate = null;\n          this.computeSize(this.id);\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id;\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate();\n        }, {\n          deep: true,\n        });\n      } else if (this.$_watchData) {\n        this.$_watchData();\n        this.$_watchData = null;\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id;\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize();\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize();\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth;\n          const height = this.$el.offsetHeight;\n          this.applyWidthHeight(width, height);\n        }\n        this.$_pendingSizeUpdate = null;\n      });\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width);\n      if (size && this.size !== size) {\n        this.applySize(size);\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--;\n        this.vscrollParent.$_undefinedMap[this.id] = undefined;\n      }\n      this.vscrollData.sizes[this.id] = size;\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return;\n      if (this.$_sizeObserved) return;\n      this.vscrollResizeObserver.observe(this.$el);\n      this.$el.$_vs_id = this.id;\n      this.$el.$_vs_onResize = this.onResize;\n      this.$_sizeObserved = true;\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return;\n      if (!this.$_sizeObserved) return;\n      this.vscrollResizeObserver.unobserve(this.$el);\n      this.$el.$_vs_onResize = undefined;\n      this.$_sizeObserved = false;\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height);\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default());\n  },\n};\n</script>\n","<template>\n  <core-scroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    :key-field=\"keyField\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n  >\n    <template\n      #default=\"{ item: itemWithSize, index, active }\"\n    >\n      <dt-scroller-item\n        :item=\"itemWithSize\"\n        :active=\"active\"\n        :size-dependencies=\"[\n          itemWithSize.message,\n        ]\"\n        :data-index=\"index\"\n      >\n        <slot\n          v-bind=\"{\n            item: itemWithSize.item,\n            index,\n            active,\n            itemWithSize,\n          }\"\n        />\n      </dt-scroller-item>\n    </template>\n  </core-scroller>\n</template>\n\n<!-- eslint-disable-next-line max-len -->\n<!-- This is a code from external library (https://github.com/Akryum/vue-virtual-scroller/blob/master/packages/vue-virtual-scroller/src/components/DynamicScroller.vue)\nWe have modified it for our own specific use. -->\n<script>\nimport CoreScroller from './core_scroller.vue';\nimport DtScrollerItem from './scroller_item.vue';\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    CoreScroller,\n    DtScrollerItem,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return;\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height;\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0];\n                width = resizeObserverSize.inlineSize;\n                height = resizeObserverSize.blockSize;\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width;\n                height = entry.contentRect.height;\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height);\n            }\n          }\n        });\n      });\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    };\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    /*\n      * The items to render.\n      * If the items are simple arrays, the index will be used as the key.\n      * If the items are objects, the keyField will be used as the key.\n     */\n    items: {\n      type: Array,\n      required: true,\n    },\n\n    /*\n      * Indicates if the items are dynamic.\n      * If true, the items will be wrapped in a DtScrollerItem component.\n      * This is required for dynamic items to be able to react to changes in their size.\n     */\n    dynamic: {\n      type: Boolean,\n      default: false,\n    },\n\n    /*\n      * The key field to use for the items.\n      * Only used if the items are objects.\n     */\n    keyField: {\n      type: String,\n      default: 'id',\n    },\n\n    /*\n      * The direction of the scroller.\n      * Can be either 'vertical' or 'horizontal'.\n     */\n    direction: {\n      type: String,\n      default: 'vertical',\n      validator: (value) => ['vertical', 'horizontal'].includes(value),\n    },\n\n    /*\n      * The tag to use for the list.\n     */\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    /*\n      * The tag to use for the items.\n     */\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    /*\n      * Display height (or width in horizontal mode) of the items in pixels\n      * used to calculate the scroll size and position.\n      * Is required for the initial render of items in DYNAMIC size mode.\n     */\n    minItemSize: {\n      type: [Number, String],\n    },\n  },\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    };\n  },\n\n  computed: {\n    simpleArray () {\n      return this.items.length && typeof this.items[0] !== 'object';\n    },\n\n    itemsWithSize () {\n      const result = [];\n      const { items, keyField, simpleArray } = this;\n      const sizes = this.vscrollData.sizes;\n      const l = items.length;\n      for (let i = 0; i < l; i++) {\n        const item = items[i];\n        const id = simpleArray ? i : item[keyField];\n        let size = sizes[id];\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0;\n        }\n        result.push({\n          item,\n          [keyField]: id,\n          size,\n        });\n      }\n      return result;\n    },\n  },\n\n  watch: {\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value;\n      },\n\n      immediate: true,\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop;\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0;\n      const length = Math.min(next.length, prev.length);\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break;\n        }\n        prevActiveTop += prev[i].size || this.minItemSize;\n        activeTop += next[i].size || this.minItemSize;\n      }\n      const offset = activeTop - prevActiveTop;\n\n      if (offset === 0) {\n        return;\n      }\n\n      this.$el.scrollTop += offset;\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = [];\n    this.$_undefinedSizes = 0;\n    this.$_undefinedMap = {};\n  },\n\n  activated () {\n    this.vscrollData.active = true;\n  },\n\n  deactivated () {\n    this.vscrollData.active = false;\n  },\n\n  methods: {\n    dynamicScrollerUpdateItems () {\n      const scroller = this.$refs.scroller;\n      if (scroller) scroller._updateVisibleItems(true);\n    },\n\n    dynamicScrollerUpdateItemsFromBottom () {\n      const scroller = this.$refs.scroller;\n      if (scroller) scroller._updateVisibleItems(false, true);\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller;\n      if (scroller) scroller.scrollToItem(index);\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return;\n      this.$_scrollingToBottom = true;\n      const el = this.$el;\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000;\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000;\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000;\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false;\n            } else {\n              requestAnimationFrame(cb);\n            }\n          });\n        };\n        requestAnimationFrame(cb);\n      });\n    },\n  },\n};\n</script>\n","<template>\n  <component\n    :is=\"dynamic ? DynamicScroller : CoreScroller\"\n    ref=\"scroller\"\n    data-qa=\"dt-scroller\"\n    :items=\"items\"\n    :item-size=\"itemSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    :key-field=\"keyField\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    :style=\"computedStyle\"\n    tabindex=\"0\"\n    @user-position=\"$emit('user-position', $event)\"\n  >\n    <template\n      #default=\"{ item, index, active }\"\n    >\n      <slot\n        v-bind=\"{\n          item: item,\n          index,\n          active,\n        }\"\n      />\n    </template>\n  </component>\n</template>\n\n<script setup>\nimport CoreScroller from './modules/core_scroller.vue';\nimport DynamicScroller from './modules/dynamic_scroller.vue';\nimport { provide, computed, watch, ref } from 'vue';\n\nconst props = defineProps({\n  /**\n      * The direction of the scroller.\n      * @values vertical, horizontal\n     */\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  /**\n     * Indicates if the items need to react to changes in their size.\n     * If disabled the itemSize prop is required and you will get improved performance.\n     * If enabled the minItemSize prop is required and you\n     * will have reduced performance but the ability to reactively size list items\n      * @values true, false\n     */\n  dynamic: {\n    type: Boolean,\n    default: false,\n  },\n\n  /**\n      * Display height (or width in horizontal mode) of the items in pixels\n      * used to calculate the scroll size and position.\n     *  Required if DYNAMIC is false\n     */\n  itemSize: {\n    type: Number,\n    default: null,\n  },\n\n  /**\n      * The tag to use for the items.\n     */\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n\n  /**\n      * The items to render.\n      * If the items are simple arrays, the index will be used as the key.\n      * If the items are objects, the keyField will be used as the key.\n     * @example items: [ 'item1', 'item2', 'item3' ]\n     * @example items: [ { id: 1, name: 'item1' }, { id: 2, name: 'item2' }, { id: 3, name: 'item3' } ]\n     */\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  /**\n      * The key field to use for the items.\n      * If the items are objects, the scroller needs to be able to identify them.\n      * By default it will look for an id field on the items.\n      * This can be configured with this prop if you are using another field name.\n     */\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  /**\n      * The tag to use for the list.\n     */\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  /**\n      * Minimum size used if the height (or width in horizontal mode) of a item is unknown.\n      * Is required for the initial render of items in DYNAMIC size mode.\n     */\n  minItemSize: {\n    type: [Number, String],\n    default: null,\n  },\n\n  /**\n      * The height of the scroller.\n      * Can be a number (in pixels) or a string (in CSS units).\n     */\n  scrollerHeight: {\n    type: [String, Number],\n    default: '100%',\n  },\n\n  /**\n    * The width of the scroller.\n    * Can be a number (in pixels) or a string (in CSS units).\n    */\n  scrollerWidth: {\n    type: [String, Number],\n    default: '100%',\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Describe when the scroller changes from start/middle/end\n   * @param {string} position The position of the scroller.\n   * @values start, middle, end\n   */\n  'user-position',\n]);\n\nprovide('emit', emits);\n\nconst scroller = ref(null);\n\nconst computedStyle = computed(() => {\n  return {\n    width: typeof props.scrollerWidth === 'number' ? `${props.scrollerWidth}px` : props.scrollerWidth,\n    height: typeof props.scrollerHeight === 'number' ? `${props.scrollerHeight}px` : props.scrollerHeight,\n  };\n});\n\nwatch(props, () => {\n  validateProps();\n}, { deep: true, immediate: true });\n\nfunction scrollToBottom () {\n  if (scroller.value) scroller.value.scrollToBottom();\n}\n\nfunction scrollToItem (index) {\n  if (scroller.value) scroller.value.scrollToItem(index);\n}\n\nfunction updateItems () {\n  if (!scroller.value) return;\n  if (props.dynamic) {\n    scroller.value.dynamicScrollerUpdateItems();\n  } else {\n    scroller.value._updateVisibleItems(true);\n  }\n}\n\nfunction updateItemsFromBottom () {\n  if (!scroller.value) return;\n  if (props.dynamic) {\n    scroller.value.dynamicScrollerUpdateItemsFromBottom();\n  } else {\n    scroller.value._updateVisibleItems(false, true);\n  }\n}\n\nfunction validateProps () {\n  if (props.dynamic && !props.minItemSize) {\n    console.error('scroller error: \\'minItemSize\\' is required on \\'dynamic\\' mode.');\n  }\n\n  if (!props.dynamic && !props.itemSize) {\n    console.error('scroller error: \\'itemSize\\' is required.');\n  }\n}\n\ndefineExpose({\n  scrollToBottom,\n  scrollToItem,\n  updateItems,\n  updateItemsFromBottom,\n});\n</script>\n"],"names":["views","reactive","unusedViews","pool","ref","hoverKey","ready","scroller","userPosition","startIndex","endIndex","scrollDirty","lastUpdateScrollPosition","sortTimer","computedMinItemSize","totalSize","uid","sizes","computed","props","items","field","minItemSize","computedMinSize","accumulator","current","i","l","simpleArray","itemIndexByKey","result","watch","_updateVisibleItems","onMounted","nextTick","_addView","index","item","key","type","nr","markRaw","view","shallowReactive","_unuseView","fake","_unusedViews","unusedPool","_getScroll","isVertical","scrollState","_itemsLimitError","_sortViews","viewA","viewB","checkItem","checkPositionDiff","itemSize","keyField","count","_sizes","_views","_pool","_itemIndexByKey","_startIndex","_endIndex","_totalSize","visibleStartIndex","visibleEndIndex","scroll","positionDiff","_buffer","h","a","b","oldI","_a","_b","_c","_d","_e","_f","remainer","continuous","unusedIndex","v","_g","_h","_scrollToPosition","position","direction","viewport","scrollDirection","scrollToItem","handleScroll","container","emit","__expose","_sfc_main","value","oldValue","oldSize","size","k","force","id","width","height","CoreScroller","DtScrollerItem","entries","entry","resizeObserverSize","next","prev","scrollTop","prevActiveTop","activeTop","length","offset","el","cb","_openBlock","_createBlock","_component_core_scroller","_mergeProps","$options","$props","_ctx","itemWithSize","active","_createVNode","_component_dt_scroller_item","_renderSlot","_normalizeProps","_guardReactiveProps","provide","emits","computedStyle","validateProps","scrollToBottom","updateItems","updateItemsFromBottom"],"mappings":"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"}