{"version":3,"file":"emoji_picker.stories-fb5038ac.js","sources":["../../components/emoji_picker/modules/emoji_search.vue","../../components/emoji_picker/modules/emoji_tabset.vue","../../components/emoji_picker/emoji_picker_constants.js","../../components/emoji_picker/composables/useKeyboardNavigation.js","../../components/emoji_picker/modules/emoji_selector.vue","../../components/emoji_picker/modules/emoji_skin_selector.vue","../../components/emoji_picker/emoji_picker.vue","../../components/emoji_picker/emoji_picker_default.story.vue"],"sourcesContent":["<template>\n  <div class=\"d-emoji-picker__search d-emoji-picker__alignment\">\n    <dt-input\n      ref=\"searchInput\"\n      :placeholder=\"searchPlaceholderLabel\"\n      :model-value=\"modelValue\"\n      @update:model-value=\"$emit('update:modelValue', $event)\"\n      @keydown.up=\"$emit('focus-tabset')\"\n      @keydown.down.prevent=\"$emit('focus-emoji-selector')\"\n      @keydown.enter=\"$emit('select-first-emoji')\"\n    >\n      <template #leftIcon>\n        <dt-icon name=\"search\" />\n      </template>\n      <template\n        v-if=\"modelValue.length > 0\"\n        #rightIcon\n      >\n        <button\n          class=\"d-emoji-picker__search-button\"\n          @click=\"clearSearch\"\n          @keydown.enter=\"clearSearch\"\n        >\n          <dt-icon\n            name=\"close\"\n          />\n        </button>\n      </template>\n    </dt-input>\n  </div>\n</template>\n\n<script setup>\nimport DtInput from '@/components/input/input.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { onMounted, ref } from 'vue';\n\ndefineProps({\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n  modelValue: {\n    type: String,\n    default: '',\n  },\n});\n\nconst emits = defineEmits(['update:modelValue', 'focus-emoji-selector', 'focus-tabset', 'select-first-emoji']);\n\nconst searchInput = ref(null);\n\nfunction clearSearch () {\n  emits('update:modelValue', '');\n  focusSearchInput();\n}\n\nfunction focusSearchInput () {\n  searchInput.value.focus();\n}\nonMounted(() => {\n  focusSearchInput();\n});\n\ndefineExpose({\n  focusSearchInput,\n});\n</script>\n\n<style scoped>\n.d-emoji-picker__search {\n  position: relative;\n  z-index: 1;\n  margin: var(--su16) var(--su24) var(--su16) var(--su16);\n  background-color: #FFFFFF;\n}\n.d-emoji-picker__search-button{\n    border: none;\n    background: none;\n    cursor: pointer;\n    margin: 0;\n    padding: 0;\n    outline: none;\n    line-height: 0;\n}\n</style>\n","<template>\n  <div class=\"d-emoji-picker__tabset\">\n    <dt-tab-group\n      tab-list-class=\"d-emoji-picker__tabset-list\"\n      :selected=\"selectedTab\"\n    >\n      <template #tabs>\n        <dt-tab\n          v-for=\"(tab, index) in tabs\"\n          :id=\"tab.id\"\n          :ref=\"el => { if (el) setTabsetRef(el) }\"\n          :key=\"tab.id\"\n          :panel-id=\"tab.panelId\"\n          :label=\"tab.label\"\n          aria-controls=\"d-emoji-picker-list\"\n          :tabindex=\"index + 1\"\n          @click.capture.stop=\"selectTabset(tab.id)\"\n          @keydown=\"handleKeyDown($event, tab.id)\"\n        >\n          <dt-icon\n            size=\"400\"\n            :name=\"tab.icon\"\n          />\n        </dt-tab>\n      </template>\n    </dt-tab-group>\n  </div>\n</template>\n\n<script setup>\nimport DtTabGroup from '@/components/tabs/tab_group.vue';\nimport DtTab from '@/components/tabs/tab.vue';\nimport DtIcon from '@/components/icon/icon.vue';\nimport { computed, ref, toRefs, watch } from 'vue';\n\nconst props = defineProps({\n  /**\n   * Whether to show the recently used tab or not\n   * @type {Boolean}\n   * @default false\n   */\n  showRecentlyUsedTab: {\n    type: Boolean,\n    default: false,\n  },\n\n  scrollIntoTab: {\n    type: Number,\n    required: true,\n  },\n\n  isScrolling: {\n    type: Boolean,\n    default: false,\n  },\n\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The labels for the aria-label\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when a tab is selected\n   * @event selected-tabset\n   * @param {String} tabId - The name of the tab that was selected\n   */\n  'selected-tabset',\n\n  'focus-search-input',\n]);\n\nconst TABS_DATA = [\n  { label: 'Recently used', icon: 'clock' },\n  { label: 'Smileyâ€™s and people', icon: 'satisfied' },\n  { label: 'Nature', icon: 'living-thing' },\n  { label: 'Food', icon: 'food' },\n  { label: 'Activity', icon: 'object' },\n  { label: 'Travel', icon: 'transportation' },\n  { label: 'Objects', icon: 'lightbulb' },\n  { label: 'Symbols', icon: 'heart' },\n  { label: 'Flags', icon: 'flag' },\n];\n\nconst tabs = computed(() => {\n  const tabsData = props.showRecentlyUsedTab ? TABS_DATA : TABS_DATA.slice(1);\n\n  return tabsData.map((tab, index) => ({\n    ...tab,\n    label: props.tabsetLabels[index],\n    id: (index + 1).toString(),\n    panelId: (index + 1).toString(),\n  }));\n});\n\nconst isSearching = computed(() => props.emojiFilter.length > 0);\n\nconst selectedTab = ref('1');\n\nconst { isScrolling } = toRefs(props);\n\nconst tabsetRef = ref([]);\n\nwatch(() => props.scrollIntoTab,\n  () => {\n    if (!isScrolling.value && !isSearching.value) {\n      selectedTab.value = (props.scrollIntoTab + 1).toString();\n    }\n  });\n\nwatch(isSearching,\n  () => {\n    if (isSearching.value) {\n      selectedTab.value = null;\n    }\n  });\n\n/**\n * We are using .capture.stop modifiers on the click event\n * because we don't want to trigger the click event of the\n * dt-tab component\n */\nfunction selectTabset (id) {\n  if (!isScrolling.value) {\n    selectedTab.value = id;\n  }\n  emits('selected-tabset', id);\n}\n\nfunction setTabsetRef (ref) {\n  // We push the $el, because $el is the button inside the dt-tab component\n  // and we need the button to focus it\n  tabsetRef.value.push(ref.$el);\n}\n\nfunction focusTabset () {\n  tabsetRef.value[0].focus();\n}\n\nfunction handleKeyDown (event, tabId) {\n  if (event.key === 'Enter') {\n    selectTabset(tabId);\n    // We blur because seems like the tab component override the selected prop, and it removes the selected style\n    tabsetRef.value[tabId - 1].blur();\n  }\n\n  if (event.key === 'Tab') {\n    event.preventDefault();\n    emits('focus-search-input');\n  }\n\n  if (event.key === 'ArrowDown') {\n    // Jump to search input\n    emits('focus-search-input');\n  }\n}\n\ndefineExpose({\n  focusTabset,\n});\n</script>\n\n<style lang=\"less\">\n.d-emoji-picker{\n  &__tabset-list{\n      gap: 4px;\n\n      &::after{\n        background-color: var(--black-200) !important;\n      }\n\n      button{\n        padding: var(--space-400);\n\n        &.d-tab--selected{\n          &::after{\n            height: var(--size-200);\n          }\n        }\n    }\n  }\n}\n</style>\n","export const CDN_URL = 'https://static.dialpadcdn.com/joypixels/png/unicode/32/';\nexport const EMOJIS_PER_ROW = 9;\n","import { ref } from 'vue';\n\nexport function useKeyboardNavigation (emits) {\n  const emojiRefs = ref([]);\n  const emojiFilteredRefs = ref([]);\n\n  const isFiltering = ref(false);\n\n  const hoverFirstEmoji = ref(true);\n\n  function hoverEmoji (emoji, isFirst = false) {\n    hoverFirstEmoji.value = isFirst;\n    emits('highlighted-emoji', emoji);\n  }\n  function setEmojiRef (el, indexTab, indexEmoji) {\n    if (!emojiRefs.value[indexTab]) {\n      emojiRefs.value[indexTab] = [];\n    }\n    emojiRefs.value[indexTab][indexEmoji] = el;\n  }\n\n  function setFilteredRef (el, index) {\n    emojiFilteredRefs.value[index] = el;\n  }\n\n  function focusEmoji (indexTab, indexEmoji) {\n    const emojiRef = isFiltering.value ? emojiFilteredRefs.value?.[indexEmoji] : emojiRefs.value?.[indexTab]?.[indexEmoji];\n\n    if (emojiRef) {\n      emojiRef.focus();\n      return true;\n    }\n\n    return false;\n  }\n\n  function handleArrowLeft (indexTab, indexEmoji) {\n    if (!focusEmoji(indexTab, indexEmoji - 1)) {\n      if (emojiRefs.value[indexTab - 1]) {\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      } else {\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n    }\n  }\n\n  function handleArrowRight (indexTab, indexEmoji) {\n    if (!focusEmoji(indexTab, indexEmoji + 1)) {\n      if (!focusEmoji(indexTab + 1, 0)) {\n        focusEmoji(0, 0);\n      }\n    }\n  }\n\n  function handleArrowLeftFiltered (indexTab, indexEmoji) {\n    if (!focusEmoji(0, indexEmoji - 1)) {\n      focusEmoji(0, emojiFilteredRefs.value.length - 1);\n    }\n  }\n\n  function handleArrowRightFiltered (indexTab, indexEmoji) {\n    if (!focusEmoji(0, indexEmoji + 1)) {\n      focusEmoji(0, 0);\n    }\n  }\n\n  function handleHorizontalNavigation (direction, indexTab, indexEmoji) {\n    if (isFiltering.value) {\n      if (direction === 'left') {\n        handleArrowLeftFiltered(indexTab, indexEmoji);\n      } else if (direction === 'right') {\n        handleArrowRightFiltered(indexTab, indexEmoji);\n      }\n    } else {\n      if (direction === 'left') {\n        handleArrowLeft(indexTab, indexEmoji);\n      } else if (direction === 'right') {\n        handleArrowRight(indexTab, indexEmoji);\n      }\n    }\n  }\n\n  return {\n    emojiRefs,\n    emojiFilteredRefs,\n    isFiltering,\n    hoverFirstEmoji,\n    setEmojiRef,\n    setFilteredRef,\n    hoverEmoji,\n    focusEmoji,\n    handleHorizontalNavigation,\n  };\n}\n","<template>\n  <div\n    class=\"d-emoji-picker__selector\"\n  >\n    <div\n      id=\"d-emoji-picker-list\"\n      ref=\"listRef\"\n      class=\"d-emoji-picker__list\"\n    >\n      <p\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__search-label d-emoji-picker__alignment\"\n      >\n        {{ filteredEmojis.length > 0 ? searchResultsLabel : searchNoResultsLabel }}\n      </p>\n      <div\n        v-else\n        ref=\"tabCategoryRef\"\n        class=\"d-emoji-picker__category d-emoji-picker__alignment\"\n      >\n        <p>\n          {{ fixedLabel }}\n        </p>\n      </div>\n      <div\n        v-for=\"(tabLabel, indexTab) in tabLabels\"\n        v-show=\"!emojiFilter\"\n        :key=\"indexTab\"\n        :ref=\"tabLabel.ref\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <p\n          v-if=\"indexTab\"\n        >\n          {{ tabLabel.label }}\n        </p>\n        <div\n          class=\"d-emoji-picker__tab\"\n        >\n          <button\n            v-for=\"(emoji, indexEmoji) in (emojis[tabs[indexTab] + skinTone] ? emojis[tabs[indexTab] + skinTone] : emojis[tabs[indexTab]])\"\n            :key=\"emoji.shortname\"\n            :ref=\"el => { if (el) setEmojiRef(el, indexTab, indexEmoji) }\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"$emit('highlighted-emoji', emoji)\"\n            @mouseleave=\"$emit('highlighted-emoji', null)\"\n            @keydown=\"event => handleKeyDown(event, indexTab, indexEmoji, emoji)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"getImgSrc(emoji.unicode_character)\"\n              @error=\"handleImageError\"\n            >\n          </button>\n        </div>\n      </div>\n      <div\n        v-if=\"emojiFilter\"\n        class=\"d-emoji-picker__alignment\"\n      >\n        <div\n          class=\"d-emoji-picker__tab \"\n          data-qa=\"filtered-emojis\"\n        >\n          <button\n            v-for=\"(emoji, index) in filteredEmojis\"\n            :key=\"emoji.shortname\"\n            :ref=\"el => { if (el) setFilteredRef(el, index) }\"\n            type=\"button\"\n            :aria-label=\"emoji.name\"\n            :class=\"{\n              'hover-emoji': (index === 0 && hoverFirstEmoji),\n            }\"\n            @click=\"$emit('selected-emoji', emoji)\"\n            @focusin=\"$emit('highlighted-emoji', emoji)\"\n            @focusout=\"$emit('highlighted-emoji', null)\"\n            @mouseover=\"hoverEmoji(emoji)\"\n            @mouseleave=\"hoverEmoji(null)\"\n            @keydown=\"event => handleKeyDownFilteredEmojis(event, index, emoji)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"emoji.name\"\n              :aria-label=\"emoji.name\"\n              :title=\"emoji.name\"\n              :src=\"`${CDN_URL + emoji.unicode_character}.png`\"\n            >\n          </button>\n        </div>\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { emojisGrouped as emojis } from '@/components/emoji_picker/emojis';\nimport { computed, onMounted, onUnmounted, ref, watch, nextTick } from 'vue';\nimport { CDN_URL, EMOJIS_PER_ROW } from '@/components/emoji_picker/emoji_picker_constants';\nimport { useKeyboardNavigation } from '@/components/emoji_picker/composables/useKeyboardNavigation';\n\nconst props = defineProps({\n  /**\n   * The filter to apply to the emoji list\n   * @type {String}\n   * @default ''\n   */\n  emojiFilter: {\n    type: String,\n    default: '',\n  },\n\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The labels for the tabset\n   * @type {Array}\n   * @required\n   */\n  tabsetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  selectedTabset: {\n    type: Object,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of recently used emojis\n   * @type {Array}\n   */\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => [],\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * Emitted when the user hover over an emoji\n   * @event highlighted-emoji\n   * @param {Object} emoji - The emoji data that was hovered\n    */\n  'highlighted-emoji',\n\n  /**\n   * Emitted when the user select an emoji\n   * @event selected-emoji\n   * @param {Object} emoji - The emoji data that was selected\n    */\n  'selected-emoji',\n\n  /**\n   * Emitted when the user scroll into an emoji tab\n   * @event scroll-into-tab\n   * @param {Number} tab-index - The tab that was scrolled into\n    */\n  'scroll-into-tab',\n\n  /**\n   * Emitted when the scrollTo function starts scrolling and stops scrolling\n   * @event is-scrolling\n   * @param {Boolean} is-scrolling - Whether the user is scrolling with the scroll-to\n    */\n  'is-scrolling',\n\n  /**\n   * Emitted when the user reach the end of the emoji list\n   * @event focus-skin-selector\n    */\n  'focus-skin-selector',\n\n  /**\n   * Emitted when the user shift tab in first tab of emoji selector\n   * @event focus-search-input\n    */\n  'focus-search-input',\n]);\n\nconst {\n  emojiRefs,\n  emojiFilteredRefs,\n  isFiltering,\n  hoverFirstEmoji,\n  setEmojiRef,\n  setFilteredRef,\n  hoverEmoji,\n  focusEmoji,\n  handleHorizontalNavigation,\n} = useKeyboardNavigation(emits);\n\n/**\n * The ref for the tab category\n * This is used to display the fixed label\n */\nconst tabCategoryRef = ref(null);\n\n/**\n * The ref for the list\n * This is used to display the tabs\n */\nconst listRef = ref(null);\n\n/**\n * The ref for the tab label observer\n * This is used to update the fixed label\n */\nconst tabLabelObserver = ref(null);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n */\nconst TABS_DATA = ['Recently used', 'People', 'Nature', 'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags'];\n\n/**\n * The list of tab labels\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n */\nconst tabLabels = computed(() => {\n  return props.recentlyUsedEmojis.length\n    ? props.tabsetLabels.map((label) => ({ label, ref: ref(null) }))\n    : props.tabsetLabels.slice(1).map((label) => ({ label, ref: ref(null) }));\n});\n\n/**\n * The label of the fixed tab\n * This is used to display the fixed label\n */\nconst fixedLabel = ref(tabLabels.value[0].label);\n\n/**\n * The list of tabs\n * This is used to display the tabs\n * This is a computed property because it will check if the recently used emojis list is empty\n * If it is empty, it will remove the recently used tab\n * The difference between this and the tab labels is that this one will set the structure of tabs\n * and the tab labels will set the labels\n */\nconst tabs = computed(() => {\n  return props.recentlyUsedEmojis.length ? TABS_DATA : TABS_DATA.slice(1);\n});\n\n/**\n * The list of current emojis that match the filter\n * This will be updated when the emojiFilter changes\n * This is used to display the search results\n * The difference between this and the current emojis list is that this one will not have the skin tone applied\n */\nconst filteredEmojis = ref([]);\n\n/**\n * The current emojis list we are displaying\n * This will be updated when the skin tone changes\n * The difference between this and the emojis list is that this one will have only the skin tone applied\n */\nconst currentEmojis = computed(() => {\n  return [\n    ...emojis[`People${props.skinTone}`],\n    ...emojis.Nature,\n    ...emojis.Food,\n    ...emojis[`Activity${props.skinTone}`],\n    ...emojis.Travel,\n    ...emojis[`Objects${props.skinTone}`],\n    ...emojis.Symbols,\n    ...emojis.Flags,\n  ];\n});\n\n/**\n * This will trigger the searchByNameAndKeywords function with debounce of 300 milliseconds\n */\nconst debouncedSearch = debounce(() => {\n  // We clean the emojiFilteredRefs to have an updated ref list for the search results\n  emojiFilteredRefs.value = [];\n  searchByNameAndKeywords();\n});\n\n/**\n * Update the current emojis list on skin tone changes\n * Also update the filtered emojis list\n * @listens skinTone\n */\nwatch(currentEmojis, () => {\n  searchByNameAndKeywords();\n}, { immediate: true });\n\n/**\n * Update the recently used emojis list on recently used emojis prop changes\n * @listens recentlyUsedEmojis\n */\nwatch(() => props.recentlyUsedEmojis,\n  () => {\n    emojis['Recently used'] = props.recentlyUsedEmojis;\n  }, { immediate: true });\n\n/**\n * Search for emojis by name and keywords\n * Will update the filtered emojis list on emojiFilter update\n * @listens emojiFilter\n */\nwatch(() => props.emojiFilter, () => {\n  resetScroll();\n  if (props.emojiFilter) {\n    isFiltering.value = true;\n  } else {\n    isFiltering.value = false;\n    // If the emoji filter is empty, emit null to remove the highlighted emoji\n    // of the previous search\n    emits('highlighted-emoji', null);\n  }\n  debouncedSearch();\n});\n\nwatch(\n  () => props.selectedTabset,\n  (tab) => {\n    scrollToTab(tab.tabId);\n  },\n  { deep: true },\n);\n\n/**\n * Filters an array of emoji objects based on a search string that matches both the name and keywords.\n * Will update the filtered emojis list\n */\nfunction searchByNameAndKeywords () {\n  const searchStr = props.emojiFilter.toLowerCase();\n  filteredEmojis.value = currentEmojis.value.filter(obj => {\n    const nameIncludesSearchStr = obj.name.toLowerCase().includes(searchStr);\n    const keywordsIncludeSearchStr = obj.keywords.some(keyword => keyword.toLowerCase().includes(searchStr));\n    return nameIncludesSearchStr || keywordsIncludeSearchStr;\n  });\n  nextTick(() => {\n    if (searchStr) {\n      hoverEmoji(filteredEmojis.value[0], true);\n    }\n  });\n}\n\nfunction debounce (fn, delay = 300) {\n  let timeout;\n\n  return (...args) => {\n    clearTimeout(timeout);\n    timeout = setTimeout(() => fn(...args), delay);\n  };\n}\n\nfunction getImgSrc (emoji) {\n  return `${CDN_URL + emoji}.png`;\n}\n\n/**\n * Handle image error - We hide the entire button if the image is not found\n */\nfunction handleImageError (event) {\n  event.target.parentNode.style.display = 'none';\n}\n\n/**\n * Scroll to the selected tab\n */\nfunction scrollToTab (tabIndex, focusFirstEmoji = true) {\n  const tabLabel = tabLabels.value[tabIndex - 1];\n  const tabElement = tabLabel.ref.value[0];\n\n  nextTick(() => {\n    const container = listRef.value;\n    const offsetTop = tabIndex === '1' ? 0 : tabElement.offsetTop - 20;\n\n    /**\n     * This variable is used to check if the user is scrolling inside the emoji picker\n     * This is used to check if the user is scrolling using the scrollTo function\n     * This is useful because this flag will prevent to update the fixed label when the user is scrolling using the scrollTo function\n     */\n    let isScrolling = true;\n\n    let prevScrollTop = container.scrollTop;\n    emits('is-scrolling', true);\n\n    /**\n     * This event listener checks whether the user is scrolling up or down by comparing the current scrollTop to prevScrollTop.\n     * If the scrollToTab function is scrolling from bottom to top and has reached the desired position (scrollTop <= offsetTop),\n     * or if the scrollToTab function is scrolling from top to bottom and has passed the desired position (scrollTop >= offsetTop),\n     * then isScrolling is set to false.\n     */\n    container.addEventListener('scroll', () => {\n      if (isScrolling) {\n        const scrollTop = container.scrollTop;\n        if (\n          (prevScrollTop < scrollTop && scrollTop >= offsetTop) ||\n          (prevScrollTop > scrollTop && scrollTop <= offsetTop)\n        ) {\n          isScrolling = false;\n          emits('is-scrolling', false);\n        }\n        prevScrollTop = scrollTop;\n      }\n    });\n\n    container.scrollTop = offsetTop;\n\n    if (focusFirstEmoji) {\n      focusEmoji((tabIndex - 1), 0);\n    }\n  });\n}\n\nfunction resetScroll () {\n  const container = listRef.value;\n\n  container.scrollTop = 0;\n}\n\n/**\n * This code creates an IntersectionObserver object that monitors the intersection between\n * the root element (tabCategoryRef) and its targets (the child elements of listRef),\n * and updates the value of the fixedLabel variable accordingly.\n */\nfunction setTabLabelObserver () {\n  /**\n   * The code extracts the target element and its index from the IntersectionObserverEntry object,\n   * and checks whether the target intersects with the root and is positioned above or below it.\n   */\n  tabLabelObserver.value = new IntersectionObserver(entries => {\n    entries.forEach(entry => {\n      const { target } = entry;\n      const index = parseInt(target.dataset.index);\n\n      /**\n       * If the target is positioned above the root,\n       * the code updates the value of the fixed label to the label of the previous tab, or the first tab if the current tab is the first one.\n       * If the target is positioned below the root, the code updates the value of the fixed label to the label of the current tab.\n       * If the target stops intersecting with the root and its index is 1 (the second tab),\n       * the code updates the value of the fixed label to the label of the first tab.\n       * NOTES:\n       * This last condition is needed because sometimes it is\n       * not detect the intersection between the root and the target.\n       * We also provide a 50 pixels offset to the root element in the first condition to always get the\n       * first tab if it has fewer emojis, because in some cases if you quickly scroll the observer does not detect it.\n       */\n      if (entry.isIntersecting && target.offsetTop <= tabCategoryRef.value.offsetTop + 50) {\n        fixedLabel.value = tabLabels.value[index - 1]?.label ?? tabLabels.value[0]?.label;\n        emits('scroll-into-tab', index - 1);\n      } else if (entry.boundingClientRect.bottom <= tabCategoryRef.value?.getBoundingClientRect().bottom) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[index]?.label;\n      } else if (index === 1) {\n        emits('scroll-into-tab', index);\n        fixedLabel.value = tabLabels.value[0]?.label;\n      }\n    });\n  });\n\n  /**\n   * The tabLabelObserver is set to observe the root element and all its children elements with\n   * the IntersectionObserver object, and sets their data-index attribute to their index.\n   */\n  tabLabelObserver.value.observe(tabCategoryRef.value);\n\n  Array.from(listRef.value.children).forEach((child, index) => {\n    tabLabelObserver.value.observe(child);\n    child.dataset.index = index;\n  });\n}\n\nconst handleKeyDownFilteredEmojis = (event, indexEmoji, emoji) => {\n  event.preventDefault();\n  hoverFirstEmoji.value = false;\n\n  if (event.key === 'ArrowUp') {\n    const position = indexEmoji % EMOJIS_PER_ROW;\n\n    if (!focusEmoji(0, indexEmoji - EMOJIS_PER_ROW)) {\n      const lastEmojiPosition = emojiFilteredRefs.value.length - (emojiFilteredRefs.value.length % EMOJIS_PER_ROW) + position;\n\n      focusEmoji(0, lastEmojiPosition);\n\n      if (!focusEmoji(0, lastEmojiPosition)) {\n        focusEmoji(0, emojiFilteredRefs.value.length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowDown') {\n    if (!focusEmoji(0, indexEmoji + EMOJIS_PER_ROW)) {\n      const position = indexEmoji % EMOJIS_PER_ROW;\n\n      if (emojiFilteredRefs.value?.[indexEmoji + (EMOJIS_PER_ROW - position)]) {\n        focusEmoji(0, emojiFilteredRefs.value.length - 1);\n      } else {\n        focusEmoji(0, position);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowLeft') {\n    handleHorizontalNavigation('left', 0, indexEmoji);\n  }\n\n  if (event.key === 'ArrowRight') {\n    handleHorizontalNavigation('right', 0, indexEmoji);\n  }\n\n  if (event.key === 'Tab') {\n    emits('focus-skin-selector');\n  }\n\n  if (event.key === 'Enter') {\n    emits('selected-emoji', emoji);\n  }\n};\n\nconst handleKeyDown = (event, indexTab, indexEmoji, emoji) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowUp') {\n    const position = indexEmoji % EMOJIS_PER_ROW;\n\n    if (indexTab === 0) {\n      // we are on the first emoji tab, then we should jump to the last row of the last emoji tab\n      const numberOfMissingEmojis = EMOJIS_PER_ROW - (emojiRefs.value[emojiRefs.value.length - 1].length % EMOJIS_PER_ROW);\n\n      const emojiToJump = emojiRefs.value[emojiRefs.value.length - 1].length + numberOfMissingEmojis - (EMOJIS_PER_ROW - position);\n\n      if (!focusEmoji(emojiRefs.value.length - 1, emojiToJump)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(emojiRefs.value.length - 1, emojiRefs.value[emojiRefs.value.length - 1].length - 1);\n      }\n      return;\n    }\n\n    // if we are not on the first tab, we should jump to the previous row of the current tab\n    if (!focusEmoji(indexTab, indexEmoji - EMOJIS_PER_ROW)) {\n      // if there is no previous row, we should jump to emoji in the sampe position of the previous tab\n      const previousTab = indexTab - 1 < 0 ? 0 : indexTab - 1;\n      const emojisInPreviousTab = emojiRefs.value[previousTab].length;\n      const lastEmojiPosition = emojisInPreviousTab - (emojisInPreviousTab % EMOJIS_PER_ROW) + position;\n\n      if (!focusEmoji(previousTab, lastEmojiPosition)) {\n        // if there is no emoji in this position, jump to the last emoji of the row\n        focusEmoji(indexTab - 1, emojiRefs.value[indexTab - 1].length - 1);\n      }\n    }\n  }\n\n  if (event.key === 'ArrowDown') {\n    if (!focusEmoji(indexTab, indexEmoji + EMOJIS_PER_ROW)) {\n      // if cannot go down\n\n      // Calculate position from cell 0 to cell 8\n      const position = indexEmoji % EMOJIS_PER_ROW;\n\n      // check if it exists a next row in the current tab\n      if (emojiRefs.value?.[indexTab]?.[indexEmoji + (EMOJIS_PER_ROW - position)]) {\n        // if it exists, we should focus the last emoji of the next row in the current tab\n        focusEmoji(indexTab, emojiRefs.value[indexTab].length - 1);\n        // if we are at the end of the list it will do nothing\n      } else {\n        // We don't have next row, we are in the last of the tab, then jump\n        // to the next tab but in the equal emoji position in row 0.\n\n        if (!focusEmoji(indexTab + 1, position)) {\n          // We are on the bottom!, should jump to the same position emoji in the first row of the first tabset\n          // if it doesn't has, jump to the last\n          if (!focusEmoji(0, position)) {\n            focusEmoji(0, emojiRefs.value[0].length - 1);\n          }\n        }\n      }\n    }\n  }\n\n  if (event.key === 'ArrowLeft') {\n    handleHorizontalNavigation('left', indexTab, indexEmoji);\n  }\n\n  if (event.key === 'ArrowRight') {\n    handleHorizontalNavigation('right', indexTab, indexEmoji);\n  }\n\n  if (event.key === 'Tab') {\n    if (focusEmoji(indexTab + 1, 0)) {\n      scrollToTab((indexTab + 1) + 1, false);\n    } else {\n      // We are on the last emoji tabset, jump to the skin selector\n      emits('focus-skin-selector');\n    }\n  }\n\n  if (event.key === 'Tab' && event.shiftKey) {\n    if (focusEmoji(indexTab, 0) && indexTab > 0) {\n      scrollToTab(indexTab, true);\n    } else {\n      scrollToTab(1, false);\n      emits('focus-search-input');\n    }\n  }\n\n  if (event.key === 'Enter') {\n    emits('selected-emoji', emoji);\n  }\n};\n\nfunction focusEmojiSelector () {\n  focusEmoji(0, 0);\n}\n\nonMounted(() => {\n  setTabLabelObserver();\n});\n\nonUnmounted(() => {\n  tabLabelObserver.value.disconnect();\n});\n\ndefineExpose({\n  focusEmojiSelector,\n});\n</script>\n\n<style lang=\"less\" scoped>\n.d-emoji-picker{\n\n  &__selector{\n    min-height: 297px;\n\n    p{\n      margin-bottom: 4px;\n      font-size: 12px;\n      font-weight: 700;\n      letter-spacing: -0.01em;\n    }\n  }\n\n  &__category {\n    background: rgba(255, 255, 255, 0.9);\n    position: sticky;\n    top: 0;\n    padding-top: 20px;\n    width: 100%;\n  }\n\n  &__list{\n    height: 100%;\n    max-height: 297px;\n    overflow-y: auto;\n    overflow-x: hidden;\n    position: relative;\n    top: -20px;\n    padding-bottom: 5px;\n\n    div:not(:first-child){\n      p{\n        margin-top: 22px;\n      }\n    }\n  }\n\n  &__search-label{\n    margin-top: 20px;\n  }\n\n  &__tab{\n    width: calc(100% + 15px);\n    max-width: 340px;\n    gap: 2px;\n    display: flex;\n    flex-wrap: wrap;\n    // We use this margin left to align the emoji list with the tabset label\n    margin-left: -6px;\n\n    button{\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      border-radius: 50%;\n      width: 36px;\n      height: 36px;\n\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      padding: 0;\n      outline: none;\n\n      &:hover, &:active{\n        background: rgba(0, 0, 0, 0.1);\n      }\n\n      &.hover-emoji{\n        background: rgba(0, 0, 0, 0.1);\n      }\n\n      &:focus{\n        box-shadow: var(--bs-focus-ring);\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div data-qa=\"skin-selector\">\n    <div\n      v-show=\"isOpen\"\n      class=\"d-emoji-picker__skin-list\"\n    >\n      <button\n        v-for=\"(skin, index) in skinList\"\n        :ref=\"el => { if (el) setSkinsRef(el) }\"\n        :key=\"skin.name\"\n        :class=\"{\n          'selected': skinSelected.skinCode === skin.skinCode,\n        }\"\n        @keydown=\"event => handleKeyDown(event, skin, index)\"\n        @click=\"selectSkin(skin)\"\n      >\n        <img\n          class=\"d-icon d-icon--size-500\"\n          :alt=\"skin.name\"\n          :aria-label=\"skin.name\"\n          :title=\"skin.name\"\n          :src=\"`${CDN_URL + skin.unicode_output}.png`\"\n        >\n      </button>\n    </div>\n    <div\n      v-show=\"!isOpen\"\n      class=\"d-emoji-picker__skin-selected\"\n    >\n      <dt-tooltip placement=\"top-end\">\n        {{ skinSelectorButtonTooltipLabel }}\n        <template #anchor>\n          <button\n            ref=\"skinSelectorRef\"\n            :aria-label=\"skinSelectorButtonTooltipLabel\"\n            @click=\"toggleSkinList\"\n            @keydown=\"event => handleKeyDown(event)\"\n          >\n            <img\n              class=\"d-icon d-icon--size-500\"\n              :alt=\"skinSelected.name\"\n              :aria-label=\"skinSelected.name\"\n              :title=\"skinSelected.name\"\n              :src=\"`${CDN_URL + skinSelected.unicode_output}.png`\"\n            >\n          </button>\n        </template>\n      </dt-tooltip>\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport { nextTick, ref, watchEffect } from 'vue';\nimport { CDN_URL } from '@/components/emoji_picker/emoji_picker_constants';\nimport DtTooltip from '@/components/tooltip/tooltip.vue';\n\nconst props = defineProps({\n  /**\n   * The skin tone to apply to the emoji list\n   * @type {String}\n   * @required\n   */\n  skinTone: {\n    type: String,\n    required: true,\n  },\n\n  isHovering: {\n    type: Boolean,\n    default: false,\n  },\n\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits([\n  /**\n   * The skin tone that was selected\n   * @event skin-tone\n   * @type {Number}\n   */\n  'skin-tone',\n  'focus-tabset',\n]);\n\nconst skinList = [\n  {\n    name: ':wave_tone1:',\n    unicode_output: '1f44b-1f3fb',\n    skinTone: 'Light',\n    skinCode: '_tone1',\n  },\n  {\n    name: ':wave_tone2:',\n    unicode_output: '1f44b-1f3fc',\n    skinTone: 'MediumLight',\n    skinCode: '_tone2',\n  },\n  {\n    name: ':wave_tone3:',\n    unicode_output: '1f44b-1f3fd',\n    skinTone: 'Medium',\n    skinCode: '_tone3',\n  },\n  {\n    name: ':wave_tone4:',\n    unicode_output: '1f44b-1f3fe',\n    skinTone: 'MediumDark',\n    skinCode: '_tone4',\n  },\n  {\n    name: ':wave_tone5:',\n    unicode_output: '1f44b-1f3ff',\n    skinTone: 'Dark',\n    skinCode: '_tone5',\n  },\n  {\n    name: ':wave:',\n    unicode_output: '1f44b',\n    skinTone: 'Default',\n    skinCode: '',\n  },\n];\n\nconst skinSelected = ref(skinList.find((skin) => skin.skinTone === props.skinTone));\n\nconst isOpen = ref(false);\n\nconst skinSelectorRef = ref(null);\n\nconst skinsRef = ref([]);\n\n/**\n * It will close the skin selector if the user is hovering over the emoji list\n */\nwatchEffect(\n  () => props.isHovering && (isOpen.value = false),\n);\n\nfunction setSkinsRef (ref) {\n  skinsRef.value.push(ref);\n}\nfunction focusSkinSelector () {\n  skinSelectorRef.value.focus();\n}\n\nfunction selectSkin (skin) {\n  skinSelected.value = skin;\n  isOpen.value = false;\n  emits('skin-tone', skin.skinTone);\n  nextTick(() => focusSkinSelector());\n}\n\nconst handleKeyDown = (event, skin, index) => {\n  event.preventDefault();\n\n  if (event.key === 'ArrowLeft') {\n    if (index === 0) skinsRef.value[skinsRef.value.length - 1]?.focus();\n    skinsRef.value[index - 1]?.focus();\n  }\n\n  if (event.key === 'ArrowRight') {\n    skinsRef.value[index + 1]?.focus();\n  }\n\n  if (event.key === 'Enter') {\n    if (skin) { selectSkin(skin); } else {\n      toggleSkinList();\n    }\n  }\n\n  if (event.key === 'Tab') {\n    emits('focus-tabset');\n  }\n};\n\nfunction toggleSkinList () {\n  isOpen.value = !isOpen.value;\n  nextTick(() => skinsRef.value[0].focus());\n}\n\ndefineExpose({\n  focusSkinSelector,\n});\n</script>\n\n<style lang=\"less\" scoped>\n.d-emoji-picker{\n  &__skin-list{\n    display: inline-flex;\n    border-radius: 40px;\n    background: rgba(0, 0, 0, 0.05);\n    flex-direction: row;\n    align-items: flex-start;\n    padding: 4px;\n    gap: 4px;\n\n    button{\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      padding: 0;\n      outline: none;\n      border-radius: 28px;\n      width: 34px;\n      height: 34px;\n\n      &:hover{\n        background: rgba(0, 0, 0, 0.1);\n        border-radius: 28px;\n      }\n\n      &.selected{\n        border: 1px solid rgba(0, 0, 0, 0.25);\n        border-radius: 28px;\n      }\n    }\n  }\n\n  &__skin-selected{\n    button{\n      border: none;\n      background: none;\n      cursor: pointer;\n      margin: 0;\n      outline: none;\n      padding: 7px;\n      display: inline-block;\n      background: rgba(0, 0, 0, 0.1);\n      border-radius: 28px;\n      width: 42px;\n      height: 42px;\n\n      &:hover{\n        background: #D2D2D2;\n      }\n    }\n  }\n}\n</style>\n","<template>\n  <div\n    class=\"d-emoji-picker\"\n  >\n    <div class=\"d-emoji-picker--header\">\n      <emoji-tabset\n        ref=\"tabsetRef\"\n        :emoji-filter=\"searchQuery\"\n        :show-recently-used-tab=\"showRecentlyUsedTab\"\n        :scroll-into-tab=\"scrollIntoTab\"\n        :tabset-labels=\"tabSetLabels\"\n        :is-scrolling=\"isScrolling\"\n        @focus-search-input=\"$refs.searchInputRef.focusSearchInput()\"\n        @selected-tabset=\"scrollToSelectedTabset\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--body\">\n      <emoji-search\n        ref=\"searchInputRef\"\n        v-model=\"searchQuery\"\n        :search-placeholder-label=\"searchPlaceholderLabel\"\n        @select-first-emoji=\"emits('selected-emoji', highlightedEmoji)\"\n        @focus-tabset=\"$refs.tabsetRef.focusTabset()\"\n        @focus-emoji-selector=\"$refs.emojiSelectorRef.focusEmojiSelector()\"\n        @keydown.esc=\"emits('close')\"\n      />\n      <emoji-selector\n        ref=\"emojiSelectorRef\"\n        :emoji-filter=\"searchQuery\"\n        :skin-tone=\"skinTone\"\n        :tabset-labels=\"tabSetLabels\"\n        :search-results-label=\"searchResultsLabel\"\n        :search-no-results-label=\"searchNoResultsLabel\"\n        :recently-used-emojis=\"recentlyUsedEmojis\"\n        :selected-tabset=\"selectedTabset\"\n        @scroll-into-tab=\"updateScrollIntoTab\"\n        @is-scrolling=\"updateIsScrolling\"\n        @highlighted-emoji=\"updateHighlightedEmoji\"\n        @selected-emoji=\"emits('selected-emoji', $event)\"\n        @focus-skin-selector=\"$refs.skinSelectorRef.focusSkinSelector()\"\n        @focus-search-input=\"$refs.searchInputRef.focusSearchInput()\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n    <div class=\"d-emoji-picker--footer\">\n      <emoji-description :emoji=\"highlightedEmoji\" />\n      <emoji-skin-selector\n        ref=\"skinSelectorRef\"\n        :is-hovering=\"!!highlightedEmoji\"\n        :skin-selector-button-tooltip-label=\"skinSelectorButtonTooltipLabel\"\n        :skin-tone=\"skinTone\"\n        @skin-tone=\"emits('skin-tone', $event)\"\n        @focus-tabset=\"$refs.tabsetRef.focusTabset()\"\n        @keydown.esc=\"emits('close')\"\n      />\n    </div>\n  </div>\n</template>\n\n<script setup>\nimport EmojiSearch from './modules/emoji_search.vue';\nimport EmojiTabset from './modules/emoji_tabset.vue';\nimport EmojiSelector from './modules/emoji_selector.vue';\nimport EmojiSkinSelector from './modules/emoji_skin_selector.vue';\nimport EmojiDescription from './modules/emoji_description.vue';\nimport { computed, ref } from 'vue';\n\nconst props = defineProps({\n  /**\n   * The array with recently used  emoji object\n   * This list is necessary to fill the recently used tab\n   * @type {Array}\n   * @default []\n   * @example\n   * <dt-emoji-picker :recentlyUsedEmojis=\"[emojiObject, emojiObject]\" />\n   */\n  // TODO try to simplify this to achieve an array of unicode characters and not an entire emoji data object\n  recentlyUsedEmojis: {\n    type: Array,\n    default: () => ([]),\n  },\n\n  /**\n   * The placeholder text for the search input\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchPlaceholderLabel=\"'Search...'\" />\n   */\n  searchPlaceholderLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search results tab\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchResultsLabel=\"'Search results'\" />\n   */\n  searchResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The label for the search no results\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :searchNoResultsLabel=\"'No results'\" />\n   */\n  searchNoResultsLabel: {\n    type: String,\n    required: true,\n  },\n\n  /**\n   * The list of tabsets to show, it is necessary to be updated with the correct language\n   * It must respect the provided order.\n   * @type {Array}\n   * @required\n   * @example\n   * <dt-emoji-picker\n   *  :tabSetLabels=\"['Most recently used', 'Smileys and people', 'Nature',\n   *    'Food', 'Activity', 'Travel', 'Objects', 'Symbols', 'Flags']\" />\n   */\n  tabSetLabels: {\n    type: Array,\n    required: true,\n  },\n\n  /**\n   * The skin tone to show the emojis\n   * This prop gives the possibility to use the skin tone selected by the user previously\n   * @type {String}\n   * @default 'Default'\n   * @values 'Default', 'Light', 'MediumLight', 'Medium', 'MediumDark', 'Dark'\n   * @example\n   * <dt-emoji-picker :skinTone=\"'Default'\" />\n   */\n  skinTone: {\n    type: String,\n    default: 'Default',\n  },\n\n  /**\n   * Tooltip shown when skin selector button is hovered.\n   * @type {String}\n   * @required\n   * @example\n   * <dt-emoji-picker :skin-selector-button-tooltip-label=\"'Change default skin tone'\" />\n   */\n  skinSelectorButtonTooltipLabel: {\n    type: String,\n    required: true,\n  },\n});\n\nconst emits = defineEmits(\n  [\n    /**\n     * It will emit the selected emoji\n     * @event selected-emoji\n     * @param {Object} emoji - The selected emoji from the emoji selector\n     */\n    'selected-emoji',\n\n    /**\n     * It will emit the selected skin tone\n     * @event skin-tone\n     * @param {String} skin - The selected skin tone from the skin selector\n     */\n    'skin-tone',\n\n    /**\n     * Since the keyboard events are encapsulated, we emit this event to close the picker\n     * @event close\n     */\n    'close',\n  ],\n);\n\nconst searchQuery = ref('');\nconst highlightedEmoji = ref(null);\nconst selectedTabset = ref({});\n\nconst scrollIntoTab = ref(0);\nconst isScrolling = ref(false);\n\nconst showRecentlyUsedTab = computed(() => props.recentlyUsedEmojis.length > 0);\n\n/**\n * Handle the selected tabset event\n * We're creating a new object with the same value as selectedTabset and assigning it back to selectedTabset.\n * Vue will see this as a new object and trigger the watcher in the child component.\n * Using this method, we are able to trigger the watcher in the child component even if the value being passed is the\n * same as the previous value.\n * @event selectedTabset\n * @param tabName {String} - The name of the tab that was selected\n */\nfunction scrollToSelectedTabset (tabId) {\n  searchQuery.value = '';\n  selectedTabset.value = tabId;\n  selectedTabset.value = { ...selectedTabset.value, tabId };\n}\n\nfunction updateScrollIntoTab (value) {\n  scrollIntoTab.value = value;\n}\n\nfunction updateIsScrolling (value) {\n  isScrolling.value = value;\n}\nfunction updateHighlightedEmoji (emoji) {\n  highlightedEmoji.value = emoji;\n}\n</script>\n\n<style lang=\"less\">\n.d-emoji-picker{\n  // fixed with to achieve accessibility in keyboard\n  // with this width we have 9 emoji per row\n  width: 372px;\n  height: 100%;\n  display: inline-flex;\n  flex-direction: column;\n  border-radius: 4px;\n\n  &--header{\n    padding: var(--su4) var(--su4) 0 var(--su8);\n    position: relative;\n    &::after{\n      content: '';\n      position: absolute;\n      right: 0;\n      bottom: 0;\n      left: 0;\n      height: 1px;\n      background-color: var(--bgc-moderate) !important;\n    }\n  }\n\n  &__alignment{\n    width: auto;\n    max-width: 340px;\n    margin: 0 16px;\n  }\n\n  &--footer{\n    position: relative;\n    height: 58px;\n    top: -20px;\n    background: #F9F9F9;\n    border-top: 1px solid var(--bc-subtle);\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    padding: 0 16px;\n  }\n}\n</style>\n","<template>\n  <dt-emoji-picker\n    :skin-tone=\"skinTone\"\n    :skin-selector-button-tooltip-label=\"$attrs.skinSelectorButtonTooltipLabel\"\n    :tab-set-labels=\"$attrs.tabSetLabels\"\n    :recently-used-emojis=\"$attrs.recentlyUsedEmojis\"\n    :search-results-label=\"$attrs.searchResultsLabel\"\n    :search-no-results-label=\"$attrs.searchNoResultsLabel\"\n    :search-placeholder-label=\"$attrs.searchPlaceholderLabel\"\n    @skin-tone=\"skinTone = $event\"\n    @selected-emoji=\"$attrs.selectedEmoji\"\n  />\n</template>\n\n<script setup>\nimport DtEmojiPicker from './emoji_picker.vue';\nimport { ref } from 'vue';\n\nconst skinTone = ref('Default');\n</script>\n"],"names":["searchInput","ref","clearSearch","emits","focusSearchInput","onMounted","expose","TABS_DATA","tabs","computed","props","tab","index","isSearching","selectedTab","isScrolling","toRefs","tabsetRef","watch","selectTabset","id","setTabsetRef","focusTabset","handleKeyDown","event","tabId","CDN_URL","EMOJIS_PER_ROW","useKeyboardNavigation","emojiRefs","emojiFilteredRefs","isFiltering","hoverFirstEmoji","hoverEmoji","emoji","isFirst","setEmojiRef","el","indexTab","indexEmoji","setFilteredRef","focusEmoji","emojiRef","_a","_c","_b","handleArrowLeft","handleArrowRight","handleArrowLeftFiltered","handleArrowRightFiltered","handleHorizontalNavigation","direction","tabCategoryRef","listRef","tabLabelObserver","tabLabels","label","fixedLabel","filteredEmojis","currentEmojis","emojis","debouncedSearch","debounce","searchByNameAndKeywords","resetScroll","scrollToTab","searchStr","obj","nameIncludesSearchStr","keywordsIncludeSearchStr","keyword","nextTick","fn","delay","timeout","args","getImgSrc","handleImageError","tabIndex","focusFirstEmoji","tabElement","container","offsetTop","prevScrollTop","scrollTop","setTabLabelObserver","entries","entry","target","_d","_e","child","handleKeyDownFilteredEmojis","position","lastEmojiPosition","numberOfMissingEmojis","emojiToJump","previousTab","emojisInPreviousTab","focusEmojiSelector","onUnmounted","skinList","skinSelected","skin","isOpen","skinSelectorRef","skinsRef","watchEffect","setSkinsRef","focusSkinSelector","selectSkin","toggleSkinList","searchQuery","highlightedEmoji","selectedTabset","scrollIntoTab","showRecentlyUsedTab","scrollToSelectedTabset","updateScrollIntoTab","value","updateIsScrolling","updateHighlightedEmoji","skinTone"],"mappings":"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"}