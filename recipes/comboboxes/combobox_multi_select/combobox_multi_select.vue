<template>
  <dt-recipe-combobox-with-popover
    ref="comboboxWithPopover"
    list-aria-label="listAriaLabel"
    :show-list="showList"
    :max-height="listMaxHeight"
    :popover-offset="popoverOffset"
    :has-suggestion-list="hasSuggestionList"
    content-width="anchor"
    @select="onComboboxSelect"
  >
    <template #input="{ onInput }">
      <span
        ref="inputSlotWrapper"
        class="d-ps-relative"
      >
        <span
          ref="chipsWrapper"
          class="d-ps-absolute d-mx2"
        >
          <dt-chip
            v-for="item in selectedItems"
            ref="chips"
            :key="item.id"
            class="d-mt4 d-mx2 d-zi-base1"
            :close-button-props="{ ariaLabel: 'close' }"
            v-on="chipListeners"
            @keyup.backspace="onChipRemove(item)"
            @close="onChipRemove(item)"
          >
            {{ item }}
          </dt-chip>
        </span>

        <dt-input
          ref="input"
          v-model="value"
          class="d-fl-grow1 d-mb4"
          :label="label"
          :description="description"
          :placeholder="placeHolder"
          :show-messages="showInputMessages"
          :messages="inputMessages"
          v-on="inputListeners"
          @input="onInput"
        />

        <dt-validation-messages
          :validation-messages="maxSelectedMessage"
          :show-messages="showValidationMessages"
        />
      </span>
    </template>

    <!-- @slot slot for popover header -->
    <template #header>
      <div
        v-if="$slots.header"
        ref="header"
      >
        <slot
          name="header"
        />
      </div>
    </template>

    <!-- @slot slot for popover list -->
    <template #list>
      <div
        ref="list"
      >
        <slot
          v-if="!loading"
          name="list"
        />
        <div
          v-else
          class="d-ta-center d-py16"
        >
          {{ loadingMessage }}
        </div>
      </div>
    </template>

    <!-- @slot slot for popover footer -->
    <template #footer>
      <div
        v-if="$slots.footer"
        ref="footer"
      >
        <slot
          name="footer"
        />
      </div>
    </template>
  </dt-recipe-combobox-with-popover>
</template>

<script>
import { DtRecipeComboboxWithPopover, DtInput, DtChip, DtValidationMessages } from '@';
import { validationMessageValidator } from '@/common/validators';

export default {
  name: 'DtRecipeComboboxMultiSelect',

  components: {
    DtRecipeComboboxWithPopover,
    DtInput,
    DtChip,
    DtValidationMessages,
  },

  props: {
    /**
     * Label for the combobox
     */
    label: {
      type: String,
      default: null,
    },

    /**
     * Description for the combobox
     */
    description: {
      type: String,
      default: null,
    },

    /**
     * Input validation messages
     */
    inputMessages: {
      type: Array,
      default: () => [],
      validator: inputMessages => {
        return validationMessageValidator(inputMessages);
      },
    },

    /**
     * Show input validation message
     */
    showInputMessages: {
      type: Boolean,
      default: true,
    },

    // @TODO: https://dialpad.atlassian.net/browse/DP-52324
    // type: {
    //   type: String,
    //   values: ['input', 'select'],
    //   default: 'select',
    // },

    /**
     * Determines if the list is loading
     */
    loading: {
      type: Boolean,
      default: false,
    },

    /**
     * The message when the list is loading
     */
    loadingMessage: {
      type: String,
      default: 'loading...',
    },

    /**
     * Determines when to show the list element and also controls the aria-expanded attribute.
     * Leaving this null will have the combobox trigger on input focus by default.
     * If you set this value, the default trigger behavior will be disabled and you can
     * control it as you need.
     */
    showList: {
      type: Boolean,
      default: null,
    },

    /**
     * Determines maximum height for the popover before overflow.
     * Possible units rem|px|em
     */
    listMaxHeight: {
      type: String,
      default: '300px',
    },

    /**
     * The selected items
     */
    selectedItems: {
      type: Array,
      default: function () { return []; },
    },

    /**
     * Would be the maximum number of selections you can make. 0 is unlimited
     */
    maxSelected: {
      type: Number,
      default: 0,
    },

    /**
     * Max select message when the max selections has been reached with the structure:
     * `[{"message": string, "type": VALIDATION_MESSAGE_TYPES }]`
     */
    maxSelectedMessage: {
      type: Array,
      default: function () { return []; },
    },

    /**
     * Displays the list when the combobox is focused, before the user has typed anything.
     * When this is enabled the list will not close after selection.
     */
    hasSuggestionList: {
      type: Boolean,
      default: true,
    },
  },

  emits: ['input', 'select', 'remove', 'max-selected'],

  data () {
    return {
      value: '',
      popoverOffset: [0, 0],
      showValidationMessages: false,
      initialInputPadding: {},
      resizeWindowObserver: null,
    };
  },

  computed: {
    placeHolder () {
      return this.selectedItems?.length > 0 ? '' : 'Select one or start typing';
    },

    chipListeners () {
      return {
        ...this.$listeners,
        keyup: event => {
          this.onChipKeyup(event);
          this.$emit('keyup', event);
        },
      };
    },

    inputListeners () {
      return {
        ...this.$listeners,
        input: event => {
          this.$emit('input', event);
        },

        keyup: event => {
          this.onInputKeyup(event);
          this.$emit('keyup', event);
        },
      };
    },
  },

  watch: {
    selectedItems: {
      immediate: true,
      async handler () {
        await this.$nextTick();
        this.setInputPadding();
        this.setInputMinWidth();
        this.checkMaxSelected();
      },
    },

    async label () {
      await this.$nextTick();
      // Adjust the chips position if label changed
      this.setChipsTopPosition();
    },

    async description () {
      await this.$nextTick();
      // Adjust the chips position if description changed
      this.setChipsTopPosition();
    },
  },

  mounted () {
    this.setChipsTopPosition();
    // Recalculate chip position and input padding when resizing window
    this.resizeWindowObserver = new ResizeObserver(() => {
      this.setChipsTopPosition();
      this.setInputPadding();
    }).observe(document.body);
  },

  beforeUnmount () {
    this.resizeWindowObserver?.unobserve(document.body);
    console.log('Combobox Multi Select: Unobserve window resize before destory');
  },

  methods: {
    onChipRemove (item) {
      this.$emit('remove', item);
      this.$refs.input.focus();
    },

    onComboboxSelect (i) {
      this.value = '';
      this.$emit('select', i);
    },

    getChipButtons () {
      return this.$refs.chips && this.$refs.chips.map(chip => chip.$el.querySelector('button'));
    },

    getChips () {
      return this.$refs.chips && this.$refs.chips.map(chip => chip.$el);
    },

    getLastChipButton () {
      return this.$refs.chips && this.getChipButtons()[this.getChipButtons().length - 1];
    },

    getLastChip () {
      return this.$refs.chips && this.getChips()[this.getChips().length - 1];
    },

    getFirstChip () {
      return this.$refs.chips && this.getChips()[0];
    },

    getInput () {
      return this.$refs.input?.$refs.input;
    },

    onChipKeyup (event) {
      const key = event.code?.toLowerCase();
      if (key === 'arrowleft') {
        // Move to the previous chip
        this.navigateBetweenChips(event.target, true);
      } else if (key === 'arrowright') {
        if (event.target.id === this.getLastChipButton().id) {
          // Move to the input if it's the last chip
          this.moveFromChipToInput();
        } else {
          // Move to the next chip
          this.navigateBetweenChips(event.target, false);
        }
      }
    },

    onInputKeyup (event) {
      const key = event.code?.toLowerCase();
      // If the cursor is at the start of the text,
      // press 'backspace' or 'left' focuses the last chip
      if (this.selectedItems.length > 0 && event.target.selectionStart === 0) {
        if (key === 'backspace' || key === 'arrowleft') {
          this.moveFromInputToChip();
        }
      }
    },

    moveFromInputToChip () {
      this.getLastChipButton().focus();
      this.$refs.input.blur();
      this.$refs.comboboxWithPopover.closeComboboxList();
    },

    moveFromChipToInput () {
      this.getLastChipButton().blur();
      this.$refs.input.focus();
      this.$refs.comboboxWithPopover.showComboboxList();
    },

    navigateBetweenChips (target, toLeft) {
      const from = this.getChipButtons().indexOf(target);
      const to = toLeft ? from - 1 : from + 1;
      if (to < 0 || to >= this.$refs.chips.length) {
        return;
      }
      this.getChipButtons()[from].blur();
      this.getChipButtons()[to].focus();
      this.$refs.comboboxWithPopover.closeComboboxList();
    },

    setChipsTopPosition () {
      // To place the chips in the input box
      // The chip "top" position should be the same line as the input box
      if (!this.$refs.input) {
        return;
      }
      const input = this.getInput();
      if (!input) return;
      const inputSlotWrapper = this.$refs.inputSlotWrapper;
      const top = input.getBoundingClientRect().top -
                  inputSlotWrapper.getBoundingClientRect().top;
      const chipsWrapper = this.$refs.chipsWrapper;
      chipsWrapper.style.top = top + 'px';
    },

    setInputPadding () {
      const lastChip = this.getLastChip();
      const input = this.getInput();
      if (!input) return;
      if (!lastChip) {
        // Revert padding if no chip
        this.revertInputPadding(input);
        return;
      }

      // Get the position of the last chip
      // The input cursor should be the same "top" as that chip and next besides it
      const left = lastChip.offsetLeft + this.getFullWidth(lastChip);
      input.style.paddingLeft = left + 'px';

      // Chip has vertical margin. We add buffer to top center the input text
      const top = lastChip.offsetTop + 3;
      input.style.paddingTop = top + 'px';

      // TODO: refresh the tippy.js instance in the popover
      // If the new chip goes to the next line and the input box expands,
      // move the popover down to the next line. Same when chips are removed
      this.popoverOffset = [0, 0];
    },

    getFullWidth (el) {
      const styles = window.getComputedStyle(el);
      return el.offsetWidth + parseInt(styles.marginLeft) + parseInt(styles.marginRight);
    },

    revertInputPadding (input) {
      input.style.paddingLeft = '';
      input.style.paddingTop = '';
      input.style.paddingBottom = '';
    },

    setInputMinWidth () {
      // Ensure the width of the input is "slightly bigger" than the width of a single chip
      const firstChip = this.getFirstChip();
      const input = this.getInput();
      if (!input) return;
      if (firstChip) {
        // Add 4px buffer for typing room
        input.style.minWidth = (this.getFullWidth(firstChip) + 4) + 'px';
      } else {
        input.style.minWidth = '';
      }
    },

    checkMaxSelected () {
      if (this.maxSelected === 0) return;
      if (this.selectedItems.length >= this.maxSelected) {
        this.showValidationMessages = true;
        this.$emit('max-selected');
      } else {
        this.showValidationMessages = false;
      }
    },
  },
};
</script>
