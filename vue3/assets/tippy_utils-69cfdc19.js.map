{"version":3,"file":"tippy_utils-69cfdc19.js","sources":["../../components/tooltip/modifiers.js","../../components/popover/tippy_utils.js"],"sourcesContent":["export const getArrowDetected = fn => ({\n  name: 'arrowDetected',\n  enabled: true,\n  phase: 'main',\n  fn,\n  requiresIfExists: ['offset'],\n});\n","import tippy, { sticky } from 'tippy.js';\nimport { getArrowDetected } from '../tooltip/modifiers';\n\nexport const BASE_TIPPY_DIRECTIONS = [\n  'bottom', 'bottom-start', 'bottom-end',\n  'right', 'right-start', 'right-end',\n  'left', 'left-start', 'left-end',\n  'top', 'top-start', 'top-end',\n];\n\nexport const TIPPY_STICKY_VALUES = [true, false, 'reference', 'popper'];\n\nexport const createTippy = (anchorElement, options) => {\n  const { contentElement } = { ...options };\n  delete options.contentElement;\n  return tippy(anchorElement, {\n    ...options,\n    plugins: [sticky],\n    render: () => getContentWrapper(contentElement),\n  });\n};\n\nexport const getPopperOptions = ({\n  boundary = 'clippingParents',\n  fallbackPlacements = [],\n  onChangePlacement = () => {},\n  hasHideModifierEnabled = false,\n  // If set to false the dialog will display over top of the anchor when there is insufficient space.\n  // if set to true it will never move from its position relative to the anchor and will clip instead.\n  tether = true,\n} = {}) => {\n  return {\n    modifiers: [\n      {\n        name: 'flip',\n        options: {\n          fallbackPlacements,\n          boundary,\n        },\n      },\n      {\n        name: 'hide',\n        enabled: hasHideModifierEnabled,\n      },\n      {\n        name: 'preventOverflow',\n        options: {\n          altAxis: !tether,\n          tether,\n        },\n      },\n      getArrowDetected(({ state }) => {\n        onChangePlacement(state.placement);\n      }),\n    ],\n  };\n};\n\nconst createAnchor = (anchorWrapper) => {\n  const span = document.createElement('span');\n  span.innerText = anchorWrapper.innerText || '';\n  anchorWrapper.innerText = '';\n  anchorWrapper.appendChild(span);\n  return span;\n};\n\nexport const getAnchor = (anchorWrapper) => {\n  const anchor = anchorWrapper?.children[0];\n  if (!anchor) return createAnchor(anchorWrapper);\n  return anchor;\n};\n\nexport const getContentWrapper = content => {\n  // The recommended structure is to use the popper as an outer wrapper\n  const popper = document.createElement('div');\n  popper.className = 'tippy-box d-ps-absolute';\n  popper.appendChild(content);\n  return {\n    popper,\n  };\n};\n"],"names":["getArrowDetected","fn","BASE_TIPPY_DIRECTIONS","TIPPY_STICKY_VALUES","createTippy","anchorElement","options","contentElement","tippy","sticky","getContentWrapper","getPopperOptions","boundary","fallbackPlacements","onChangePlacement","hasHideModifierEnabled","tether","state","createAnchor","anchorWrapper","span","getAnchor","anchor","content","popper"],"mappings":"mDAAO,MAAMA,EAAmBC,IAAO,CACrC,KAAM,gBACN,QAAS,GACT,MAAO,OACP,GAAAA,EACA,iBAAkB,CAAC,QAAQ,CAC7B,GCHaC,EAAwB,CACnC,SAAU,eAAgB,aAC1B,QAAS,cAAe,YACxB,OAAQ,aAAc,WACtB,MAAO,YAAa,SACtB,EAEaC,EAAsB,CAAC,GAAM,GAAO,YAAa,QAAQ,EAEzDC,EAAc,CAACC,EAAeC,IAAY,CACrD,KAAM,CAAE,eAAAC,CAAc,EAAK,CAAE,GAAGD,CAAO,EACvC,cAAOA,EAAQ,eACRE,EAAMH,EAAe,CAC1B,GAAGC,EACH,QAAS,CAACG,CAAM,EAChB,OAAQ,IAAMC,EAAkBH,CAAc,CAClD,CAAG,CACH,EAEaI,EAAmB,CAAC,CAC/B,SAAAC,EAAW,kBACX,mBAAAC,EAAqB,CAAE,EACvB,kBAAAC,EAAoB,IAAM,CAAE,EAC5B,uBAAAC,EAAyB,GAGzB,OAAAC,EAAS,EACX,EAAI,MACK,CACL,UAAW,CACT,CACE,KAAM,OACN,QAAS,CACP,mBAAAH,EACA,SAAAD,CACD,CACF,EACD,CACE,KAAM,OACN,QAASG,CACV,EACD,CACE,KAAM,kBACN,QAAS,CACP,QAAS,CAACC,EACV,OAAAA,CACD,CACF,EACDhB,EAAiB,CAAC,CAAE,MAAAiB,KAAY,CAC9BH,EAAkBG,EAAM,SAAS,CACzC,CAAO,CACF,CACL,GAGMC,EAAgBC,GAAkB,CACtC,MAAMC,EAAO,SAAS,cAAc,MAAM,EAC1C,OAAAA,EAAK,UAAYD,EAAc,WAAa,GAC5CA,EAAc,UAAY,GAC1BA,EAAc,YAAYC,CAAI,EACvBA,CACT,EAEaC,EAAaF,GAAkB,CAC1C,MAAMG,EAASH,GAAA,YAAAA,EAAe,SAAS,GACvC,OAAKG,GAAeJ,EAAaC,CAAa,CAEhD,EAEaT,EAAoBa,GAAW,CAE1C,MAAMC,EAAS,SAAS,cAAc,KAAK,EAC3C,OAAAA,EAAO,UAAY,0BACnBA,EAAO,YAAYD,CAAO,EACnB,CACL,OAAAC,CACJ,CACA"}